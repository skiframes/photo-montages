<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <title>SkiFrames - Calibration</title>
    <style>
        :root {
            --primary: #2563eb;
            --primary-dark: #1d4ed8;
            --danger: #dc2626;
            --success: #16a34a;
            --bg: #f8fafc;
            --card: #ffffff;
            --text: #1e293b;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --start-zone: rgba(34, 197, 94, 0.5);
            --end-zone: rgba(239, 68, 68, 0.5);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            padding-bottom: env(safe-area-inset-bottom);
        }

        .header {
            background: var(--primary);
            color: white;
            padding: 16px;
            text-align: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
        }

        .container {
            padding: 16px;
            max-width: 600px;
            margin: 0 auto;
        }

        .card {
            background: var(--card);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .card-title {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }

        label {
            display: block;
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        select, input {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: white;
            margin-bottom: 12px;
            -webkit-appearance: none;
        }

        /* Restore checkbox appearance */
        input[type="checkbox"] {
            width: auto;
            padding: 0;
            margin-bottom: 0;
            -webkit-appearance: checkbox;
            appearance: checkbox;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
        }

        .btn {
            display: block;
            width: 100%;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
        }

        .btn-primary:disabled {
            background: var(--border);
            color: var(--text-muted);
            cursor: not-allowed;
        }

        .btn-danger {
            background: var(--danger);
            color: white;
        }

        .btn-success {
            background: var(--success);
            color: white;
        }

        .btn-outline {
            background: white;
            border: 2px solid var(--primary);
            color: var(--primary);
        }

        .btn-sm {
            padding: 10px 16px;
            font-size: 14px;
            width: auto;
            display: inline-block;
        }

        .btn-group {
            display: flex;
            gap: 8px;
        }

        .btn-group .btn {
            flex: 1;
        }

        /* Frame display area */
        .frame-container {
            position: relative;
            width: 100%;
            background: #1e293b;
            border-radius: 8px;
            overflow: hidden;
            touch-action: none;
        }

        .frame-container img {
            width: 100%;
            height: auto;
            display: block;
        }

        .frame-placeholder {
            aspect-ratio: 16/9;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-muted);
            font-size: 14px;
        }

        /* Zone overlays */
        .zone-overlay {
            position: absolute;
            border: 3px solid;
            pointer-events: none;
        }

        .zone-overlay.start {
            border-color: #22c55e;
            background: var(--start-zone);
        }

        .zone-overlay.end {
            border-color: #ef4444;
            background: var(--end-zone);
        }

        .zone-label {
            position: absolute;
            top: 4px;
            left: 4px;
            background: inherit;
            color: white;
            font-size: 12px;
            font-weight: 600;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .zone-overlay.start .zone-label {
            background: #22c55e;
        }

        .zone-overlay.end .zone-label {
            background: #ef4444;
        }

        /* Drawing indicator */
        .drawing-active {
            cursor: crosshair;
        }

        .drawing-indicator {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 12px 24px;
            border-radius: 24px;
            font-size: 14px;
            font-weight: 500;
            z-index: 200;
            display: none;
        }

        .drawing-indicator.visible {
            display: block;
        }

        /* Zone buttons */
        .zone-buttons {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .zone-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid var(--border);
            border-radius: 8px;
            background: white;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .zone-btn.start {
            border-color: #22c55e;
            color: #22c55e;
        }

        .zone-btn.start.active, .zone-btn.start:active {
            background: #22c55e;
            color: white;
        }

        .zone-btn.end {
            border-color: #ef4444;
            color: #ef4444;
        }

        .zone-btn.end.active, .zone-btn.end:active {
            background: #ef4444;
            color: white;
        }

        .zone-btn.crop {
            border-color: #3b82f6;
            color: #3b82f6;
        }

        .zone-btn.crop.active, .zone-btn.crop:active {
            background: #3b82f6;
            color: white;
        }

        .zone-overlay.crop {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.3);
        }

        /* End Mode Toggle */
        .end-mode-toggle {
            display: flex;
            gap: 0;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .end-mode-btn {
            flex: 1;
            padding: 10px 16px;
            border: none;
            background: white;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-muted);
        }

        .end-mode-btn:first-child {
            border-right: 1px solid var(--border);
        }

        .end-mode-btn.active {
            background: var(--primary);
            color: white;
        }

        .end-mode-btn:hover:not(.active) {
            background: var(--bg);
        }

        .fps-grid {
            display: grid;
            grid-template-columns: repeat(10, 1fr);
            gap: 4px;
            margin-top: 4px;
        }

        .fps-btn {
            padding: 8px 2px;
            border: 1px solid var(--border);
            border-radius: 6px;
            background: white;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            color: var(--text-muted);
            text-align: center;
        }

        .fps-btn.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .fps-btn:hover:not(.active) {
            background: var(--bg);
        }

        /* Montage Gallery */
        .montage-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 8px;
            margin-top: 8px;
        }

        .montage-thumb {
            position: relative;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
            cursor: pointer;
            transition: transform 0.2s;
        }

        .montage-thumb:hover {
            transform: scale(1.02);
        }

        .montage-thumb img {
            width: 100%;
            display: block;
        }

        .montage-thumb .montage-fps-tag {
            position: absolute;
            top: 4px;
            right: 4px;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 10px;
            font-weight: 600;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .montage-thumb .montage-label {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: rgba(0,0,0,0.6);
            color: white;
            font-size: 10px;
            padding: 3px 6px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        /* Montage fullscreen overlay */
        .montage-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            z-index: 10000;
            justify-content: center;
            align-items: center;
            cursor: pointer;
        }

        .montage-overlay.visible {
            display: flex;
        }

        .montage-overlay img {
            max-width: 95vw;
            max-height: 95vh;
            object-fit: contain;
        }

        /* Slider */
        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            border-radius: 4px;
            background: var(--border);
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
        }

        /* Status messages */
        .status {
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            margin-bottom: 12px;
        }

        .status.success {
            background: #dcfce7;
            color: #166534;
        }

        .status.error {
            background: #fee2e2;
            color: #991b1b;
        }

        .status.info {
            background: #dbeafe;
            color: #1e40af;
        }

        /* Active session banner */
        .active-session {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
        }

        .active-session strong {
            color: #92400e;
        }

        /* Time picker styling */
        input[type="time"], input[type="datetime-local"] {
            padding: 12px;
        }

        /* Advanced settings toggle */
        .advanced-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 0;
            cursor: pointer;
            border-top: 1px solid var(--border);
            margin-top: 12px;
        }

        .advanced-settings {
            display: none;
            padding-top: 12px;
        }

        .advanced-settings.visible {
            display: block;
        }

        /* Loading spinner */
        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid white;
            border-top-color: transparent;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 8px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Pinch zoom support */
        .frame-wrapper {
            overflow: hidden;
            max-height: 60vh;
            touch-action: none;
        }

        .frame-inner {
            position: relative;
            transform-origin: 0 0;
        }

        /* Zoom controls */
        .zoom-controls {
            display: flex;
            gap: 8px;
            margin-top: 8px;
            justify-content: center;
        }

        .zoom-btn {
            width: 44px;
            height: 44px;
            border: 1px solid var(--border);
            border-radius: 8px;
            background: white;
            font-size: 20px;
            cursor: pointer;
        }

        .zoom-btn:active {
            background: var(--bg);
        }

        /* Help text */
        .help-text {
            font-size: 12px;
            color: var(--text-muted);
            margin-top: 4px;
        }

        /* Gate calibration pins */
        .gate-pin {
            position: absolute;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 3px solid white;
            transform: translate(-50%, -50%);
            cursor: grab;
            z-index: 10;
            touch-action: none;
            box-shadow: 0 1px 4px rgba(0,0,0,0.5);
        }
        .gate-pin:active, .gate-pin.dragging {
            cursor: grabbing;
            box-shadow: 0 0 10px rgba(255,255,255,0.9);
            transform: translate(-50%, -50%) scale(1.3);
        }
        .gate-pin.red { background: rgba(220, 38, 38, 0.85); }
        .gate-pin.blue { background: rgba(37, 99, 235, 0.85); }
        .gate-pin.dismissed { opacity: 0.25; pointer-events: none; }

        .gate-label {
            position: absolute;
            background: rgba(0,0,0,0.75);
            color: white;
            font-size: 11px;
            font-weight: 600;
            padding: 1px 5px;
            border-radius: 4px;
            pointer-events: none;
            z-index: 11;
            transform: translate(8px, -50%);
        }

        .gate-line {
            position: absolute;
            pointer-events: none;
            z-index: 9;
        }

        .gate-dismiss {
            position: absolute;
            width: 26px;
            height: 26px;
            border-radius: 50%;
            background: rgba(220, 38, 38, 0.9);
            color: white;
            font-size: 16px;
            line-height: 26px;
            text-align: center;
            cursor: pointer;
            z-index: 12;
            border: none;
            transform: translate(-50%, -50%);
            font-weight: bold;
        }

        /* GPS styles */
        .gps-section {
            margin-top: 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
        }
        .gps-toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: #f0fdf4;
            cursor: pointer;
        }
        .gps-toggle-row label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text);
            cursor: pointer;
        }
        .gps-body {
            padding: 10px 12px;
            display: none;
            font-size: 13px;
        }
        .gps-body.visible { display: block; }
        .gps-accuracy {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 10px;
            font-weight: 600;
            font-size: 13px;
        }
        .gps-accuracy.rtk { background: #dcfce7; color: #15803d; }
        .gps-accuracy.good { background: #dbeafe; color: #1d4ed8; }
        .gps-accuracy.fair { background: #fef3c7; color: #92400e; }
        .gps-accuracy.poor { background: #fecaca; color: #991b1b; }
        .gps-camera-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-top: 8px;
        }
        .gps-status-dot {
            display: inline-block;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #94a3b8;
        }
        .gps-status-dot.captured { background: #16a34a; }
        .gps-status-dot.watching { background: #f59e0b; animation: gpsPulse 1.5s infinite; }
        @keyframes gpsPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* GPS walk overlay */
        .gps-walk-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.92);
            z-index: 1000;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
        }
        .gps-walk-overlay.visible { display: flex; }
        .gps-walk-gate-label {
            font-size: 22px;
            font-weight: 700;
            margin-bottom: 8px;
        }
        .gps-walk-accuracy {
            font-size: 48px;
            font-weight: 700;
            margin: 16px 0;
        }
        .gps-walk-quality-bar {
            width: 200px;
            height: 6px;
            border-radius: 3px;
            background: #334155;
            margin-bottom: 24px;
            overflow: hidden;
        }
        .gps-walk-quality-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.3s, background 0.3s;
        }
        .gps-walk-buttons {
            display: flex;
            gap: 16px;
            margin-bottom: 24px;
        }
        .gps-walk-buttons .btn {
            min-width: 120px;
            padding: 16px 24px;
            font-size: 18px;
        }
        .gps-walk-dots {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            justify-content: center;
            margin-bottom: 16px;
        }
        .gps-walk-dot {
            width: 14px; height: 14px;
            border-radius: 50%;
            background: #475569;
        }
        .gps-walk-dot.captured { background: #16a34a; }
        .gps-walk-dot.current { background: #3b82f6; box-shadow: 0 0 8px rgba(59,130,246,0.6); }
        .gps-walk-cancel {
            color: #94a3b8;
            font-size: 14px;
            cursor: pointer;
            margin-top: 8px;
        }
        .gps-walk-cancel:hover { color: white; }

        /* GPS dot on gate pins */
        .gate-pin-gps {
            position: absolute;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #16a34a;
            border: 1.5px solid white;
            top: -3px; right: -3px;
            z-index: 13;
            pointer-events: none;
        }

        /* GPS summary in review card */
        .gps-summary {
            margin-top: 8px;
            font-size: 12px;
            color: var(--text-muted);
        }
        .gps-summary-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 2px 0;
        }
    </style>
</head>
<body>
    <header class="header">
        <h1>SkiFrames Calibration</h1>
    </header>

    <div class="container">
        <!-- Mode Selection -->
        <div class="card">
            <div class="card-title">Mode</div>
            <div class="btn-group">
                <button class="btn btn-primary mode-btn" id="modeCalibration">
                    Photo Montage
                </button>
                <button class="btn btn-outline mode-btn" id="modeGallery">
                    Gallery
                </button>
                <button class="btn btn-outline mode-btn" id="modeStitch">
                    Video Stitch
                </button>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- GALLERY MODE UI                            -->
        <!-- ============================================ -->
        <div id="galleryMode" style="display: none;">
            <div class="card">
                <div class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
                    Recent Montages
                    <span id="galleryMontageCount" style="font-size: 12px; color: var(--text-muted); font-weight: normal;"></span>
                </div>

                <!-- FPS Filter -->
                <div id="galleryFpsFilter" style="margin-bottom: 12px;">
                    <label style="font-size: 13px; margin-bottom: 6px; display: block;">Filter by FPS</label>
                    <div class="fps-grid" id="galleryFpsButtons">
                    </div>
                </div>

                <div id="galleryGrid" class="montage-grid">
                    <div style="color: var(--text-muted); font-size: 14px; text-align: center; padding: 20px;">
                        Loading montages...
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- VIDEO STITCH MODE UI                       -->
        <!-- ============================================ -->
        <div id="stitchMode" style="display: none;">
            <!-- Step 1: Select Vola & Race -->
            <div class="card">
                <div class="card-title">1. Select Race Data</div>

                <label for="stitchVolaFile">Vola Excel File</label>
                <select id="stitchVolaFile">
                    <option value="">Loading...</option>
                </select>

                <label for="stitchStartlistFile" style="margin-top: 8px;">Start List PDF (for names/teams)</label>
                <select id="stitchStartlistFile">
                    <option value="">-- None (use bib numbers) --</option>
                </select>

                <label for="stitchResultsFile" style="margin-top: 8px;">Results PDF (for USSA IDs & rankings)</label>
                <select id="stitchResultsFile">
                    <option value="">-- None --</option>
                </select>

                <label for="stitchRace" style="margin-top: 8px;">Age Group / Run</label>
                <select id="stitchRace">
                    <option value="U12 run 1">U12 Run 1</option>
                    <option value="U12 run 2">U12 Run 2</option>
                    <option value="U14 run 1">U14 Run 1</option>
                    <option value="U14 run 2">U14 Run 2</option>
                </select>

                <!-- Race Info Fields (for manifest and title overlay) -->
                <div style="margin-top: 12px; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: #334155;">Race Information</div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>
                            <label for="raceInfoEvent" style="font-size: 12px; margin-bottom: 2px;">Event</label>
                            <input type="text" id="raceInfoEvent" value="Western Division Ranking" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoDiscipline" style="font-size: 12px; margin-bottom: 2px;">Discipline</label>
                            <input type="text" id="raceInfoDiscipline" value="SL" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoAgeGroup" style="font-size: 12px; margin-bottom: 2px;">Age Group</label>
                            <input type="text" id="raceInfoAgeGroup" value="U14" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoRun" style="font-size: 12px; margin-bottom: 2px;">Run</label>
                            <input type="text" id="raceInfoRun" value="Run 1" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoDate" style="font-size: 12px; margin-bottom: 2px;">Date</label>
                            <input type="text" id="raceInfoDate" value="2026-02-01" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoType" style="font-size: 12px; margin-bottom: 2px;">Type</label>
                            <input type="text" id="raceInfoType" value="USSA/NHARA" style="font-size: 13px;">
                        </div>
                    </div>

                    <div style="font-weight: 600; margin: 12px 0 8px 0; color: #334155;">Course Information</div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <div>
                            <label for="raceInfoCourse" style="font-size: 12px; margin-bottom: 2px;">Course Name</label>
                            <input type="text" id="raceInfoCourse" value="Flying Yankee" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoLocation" style="font-size: 12px; margin-bottom: 2px;">Location</label>
                            <input type="text" id="raceInfoLocation" value="Ragged Mountain, NH" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoVertical" style="font-size: 12px; margin-bottom: 2px;">Vertical Drop</label>
                            <input type="text" id="raceInfoVertical" value="85m" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoLength" style="font-size: 12px; margin-bottom: 2px;">Length</label>
                            <input type="text" id="raceInfoLength" value="305m" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoGates" style="font-size: 12px; margin-bottom: 2px;">Gates</label>
                            <input type="text" id="raceInfoGates" value="35" style="font-size: 13px;">
                        </div>
                        <div>
                            <label for="raceInfoSnow" style="font-size: 12px; margin-bottom: 2px;">Snow Conditions</label>
                            <input type="text" id="raceInfoSnow" value="Packed Powder" style="font-size: 13px;">
                        </div>
                    </div>

                    <div class="help-text" style="margin-top: 8px;">Title overlay: Event | Discipline | Age Group | Run</div>
                </div>

                <!-- Logo Selection -->
                <div style="margin-top: 12px; padding: 12px; background: #f8fafc; border-radius: 8px; border: 1px solid #e2e8f0;">
                    <div style="font-weight: 600; margin-bottom: 8px; color: #334155;">Logo Selection</div>
                    <div class="help-text" style="margin-bottom: 8px;">Drag to reorder. Uncheck to hide.</div>
                    <div id="logoList" style="display: flex; flex-direction: column; gap: 4px;">
                        <!-- Logos will be populated dynamically -->
                    </div>
                </div>

                <div style="margin-top: 12px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="stitchGenerateComparison" style="width: 18px; height: 18px;">
                        <span>Generate comparison videos vs fastest racer</span>
                    </label>
                    <div class="help-text">Creates additional videos showing time difference vs fastest in each gender category</div>
                </div>

                <div style="margin-top: 12px;">
                    <label for="stitchTestCount" style="display: inline-block; margin-bottom: 0;">Test count (0 = all)</label>
                    <input type="number" id="stitchTestCount" value="3" min="0" max="100" style="width: 80px; display: inline-block; margin-left: 10px; margin-bottom: 0;">
                    <div class="help-text">Number of athletes to process for testing. Set to 0 to process all.</div>
                </div>

                <div style="margin-top: 12px; display: flex; gap: 20px;">
                    <div>
                        <label for="stitchPreBuffer" style="display: inline-block; margin-bottom: 0;">Pre-buffer (sec)</label>
                        <input type="number" id="stitchPreBuffer" value="2" min="0" max="10" step="0.5" style="width: 70px; display: inline-block; margin-left: 10px;">
                    </div>
                    <div>
                        <label for="stitchPostBuffer" style="display: inline-block; margin-bottom: 0;">Post-buffer (sec)</label>
                        <input type="number" id="stitchPostBuffer" value="2" min="0" max="10" step="0.5" style="width: 70px; display: inline-block; margin-left: 10px;">
                    </div>
                </div>
                <div class="help-text">Seconds before start and after finish to include in video. Timer shows 0:00 at racer start.</div>

                <button id="stitchLoadRacers" class="btn btn-primary" style="margin-top: 12px;">
                    Load Racers
                </button>

                <div id="stitchRacersInfo" style="display: none; margin-top: 12px; padding: 12px; background: #f0fdf4; border-radius: 8px; border: 1px solid #bbf7d0;">
                    <strong style="color: #166534;">Racers Loaded:</strong> <span id="stitchRacerCount">0</span>
                    <div style="margin-top: 8px; max-height: 150px; overflow-y: auto; font-size: 13px;">
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="text-align: left; border-bottom: 1px solid #d1d5db;">
                                    <th style="padding: 4px;">Bib</th>
                                    <th style="padding: 4px;">Name</th>
                                    <th style="padding: 4px;">Team</th>
                                    <th style="padding: 4px;">Start</th>
                                    <th style="padding: 4px;">Duration</th>
                                </tr>
                            </thead>
                            <tbody id="stitchRacersTable"></tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Step 2: Configure Cut Points -->
            <div class="card" id="stitchCutsCard" style="display: none;">
                <div class="card-title">2. Configure Camera Cut Points</div>

                <label for="stitchConfigSelect">Load Saved Config</label>
                <select id="stitchConfigSelect">
                    <option value="">-- New Configuration --</option>
                </select>

                <div style="margin-top: 16px;">
                    <p class="help-text" style="margin-bottom: 12px;">
                        Set when each camera's segment starts/ends as a percentage of run time.
                        R1 start uses pre-buffer setting, R3 end uses post-buffer setting.
                    </p>

                    <div id="stitchCutsContainer">
                        <!-- R1 (start controlled by pre-buffer) -->
                        <div class="cut-row" style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                            <label style="width: 60px; margin: 0;">R1</label>
                            <input type="hidden" id="stitchCutR1Start" value="0">
                            <span style="color: #6b7280; font-size: 13px;">(pre-buffer) to</span>
                            <input type="number" id="stitchCutR1End" value="7" step="1" style="width: 70px; margin: 0;">
                            <span>%</span>
                        </div>
                        <!-- Axis -->
                        <div class="cut-row" style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                            <label style="width: 60px; margin: 0;">Axis</label>
                            <input type="number" id="stitchCutAxisStart" value="7" step="1" style="width: 70px; margin: 0;">
                            <span>% to</span>
                            <input type="number" id="stitchCutAxisEnd" value="51" step="0.5" style="width: 70px; margin: 0;">
                            <span>%</span>
                        </div>
                        <!-- R2 -->
                        <div class="cut-row" style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                            <label style="width: 60px; margin: 0;">R2</label>
                            <input type="number" id="stitchCutR2Start" value="51" step="0.5" style="width: 70px; margin: 0;">
                            <span>% to</span>
                            <input type="number" id="stitchCutR2End" value="72" step="0.5" style="width: 70px; margin: 0;">
                            <span>%</span>
                        </div>
                        <!-- R3 (end controlled by post-buffer) -->
                        <div class="cut-row" style="display: flex; gap: 8px; margin-bottom: 8px; align-items: center;">
                            <label style="width: 60px; margin: 0;">R3</label>
                            <input type="number" id="stitchCutR3Start" value="72" step="0.5" style="width: 70px; margin: 0;">
                            <span>% to</span>
                            <input type="hidden" id="stitchCutR3End" value="100">
                            <span style="color: #6b7280; font-size: 13px;">(post-buffer)</span>
                        </div>
                    </div>

                    <div style="margin-top: 12px;">
                        <label for="stitchConfigName" style="font-size: 13px;">Config Name (to save)</label>
                        <div style="display: flex; gap: 8px;">
                            <input type="text" id="stitchConfigName" placeholder="e.g., U12 run 1" style="flex: 1; margin: 0;">
                            <button id="stitchSaveConfig" class="btn btn-outline btn-sm">Save</button>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Step 3: Videos Info (auto-detected) -->
            <div class="card" id="stitchVideosCard" style="display: none;">
                <div class="card-title">3. Camera Videos (Auto-detected)</div>

                <p class="help-text" style="margin-bottom: 12px;">
                    Videos automatically selected from /Volumes/OWC_48/data/recordings/
                </p>

                <div id="stitchVideosList" style="font-size: 13px;">
                    <div style="margin-bottom: 6px;"><strong>R1:</strong> <span id="stitchVideoR1Display">-</span></div>
                    <div style="margin-bottom: 6px;"><strong>Axis:</strong> <span id="stitchVideoAxisDisplay">-</span></div>
                    <div style="margin-bottom: 6px;"><strong>R2:</strong> <span id="stitchVideoR2Display">-</span></div>
                    <div style="margin-bottom: 6px;"><strong>R3:</strong> <span id="stitchVideoR3Display">-</span></div>
                </div>

                <div id="stitchVideosMissing" style="display: none; margin-top: 12px; padding: 10px; background: #fef2f2; border-radius: 6px; color: #dc2626;">
                    <strong>Warning:</strong> Some camera videos not found. Check recordings directory.
                </div>
            </div>

            <!-- Step 4: Process -->
            <div class="card" id="stitchProcessCard" style="display: none;">
                <div class="card-title">4. Generate Stitched Videos</div>

                <label for="stitchProcessLocation">Processing Location</label>
                <select id="stitchProcessLocation" style="margin-bottom: 12px;">
                    <option value="local">Local (M1 Mac - 8 workers)</option>
                    <option value="server" selected>Remote Server (4T - 16 workers)</option>
                </select>

                <div id="localProcessingControls" style="display: none;">
                    <button id="stitchStartProcess" class="btn btn-success" style="font-size: 18px; padding: 16px;">
                        Start Processing
                    </button>

                    <button id="stitchStopProcess" class="btn btn-danger" style="display: none; margin-top: 12px; font-size: 16px; padding: 14px;">
                        Stop Processing
                    </button>
                </div>

                <div id="serverProcessingControls">
                    <p style="color: #6b7280; font-size: 14px; margin-bottom: 12px;">
                        Generate command to run on Tesla GPU server (4T). Copy and paste into terminal.
                    </p>
                    <button id="stitchGenerateCommand" class="btn btn-primary" style="font-size: 16px; padding: 14px;">
                        Generate Server Command
                    </button>
                    <div id="serverCommandOutput" style="display: none; margin-top: 12px;">
                        <label>SSH Command (copy this):</label>
                        <textarea id="serverCommandText" readonly style="width: 100%; height: 80px; font-family: monospace; font-size: 12px; background: #1e293b; color: #22c55e; padding: 10px; border-radius: 6px; border: none;"></textarea>
                        <button id="copyServerCommand" class="btn" style="margin-top: 8px; background: #475569; color: white;">
                            Copy to Clipboard
                        </button>
                    </div>
                </div>

                <div id="stitchProgress" style="display: none; margin-top: 16px;">
                    <div style="background: #e5e7eb; border-radius: 8px; height: 24px; overflow: hidden;">
                        <div id="stitchProgressBar" style="background: #22c55e; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="margin-top: 8px; text-align: center;">
                        <span id="stitchProgressText">Processing racer 0 of 0</span>
                    </div>
                    <div id="stitchCurrentRacer" style="margin-top: 4px; text-align: center; font-size: 14px; color: #6b7280;"></div>
                </div>

                <div id="stitchResults" style="display: none; margin-top: 16px; padding: 12px; background: #f0fdf4; border-radius: 8px;">
                    <strong style="color: #166534;">Completed!</strong>
                    <div id="stitchOutputDir" style="margin-top: 4px; font-size: 13px;"></div>
                    <div id="stitchOutputCount" style="margin-top: 4px; font-size: 13px;"></div>
                </div>

                <div id="stitchError" style="display: none; margin-top: 16px; padding: 12px; background: #fef2f2; border-radius: 8px; color: #dc2626;">
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- PHOTO MONTAGE MODE (Gates + Free Skiing)   -->
        <!-- ============================================ -->
        <div id="montageMode">

            <!-- Sub-mode toggle: Calibration (optional) vs Session Setup -->
            <div class="card">
                <div class="card-title">Photo Montage Mode</div>
                <div class="btn-group">
                    <button class="btn btn-outline mode-btn" id="subModeGates">Calibrate (Optional)</button>
                    <button class="btn btn-primary mode-btn" id="subModeFreeSki">Session Setup</button>
                </div>
            </div>

            <!-- ======= CALIBRATION SUB-MODE (Optional) ======= -->
            <div id="gatesMode" style="display: none;">
                <!-- Card 1: Frame Source -->
                <div class="card">
                    <div class="card-title">1. Frame Source</div>

                    <label for="gatesSourceType">Source</label>
                    <div class="btn-group" style="margin-bottom: 12px;">
                        <button class="btn btn-primary btn-sm" id="gatesSourceRtsp">RTSP</button>
                        <button class="btn btn-outline btn-sm" id="gatesSourceVideo">Video File</button>
                    </div>

                    <div id="gatesRtspSection">
                        <label for="gatesCameraSelect">Camera</label>
                        <select id="gatesCameraSelect"></select>
                    </div>

                    <div id="gatesVideoSection" style="display: none;">
                        <label for="gatesVideoDropdown">Video File</label>
                        <select id="gatesVideoDropdown">
                            <option value="">Select a video...</option>
                        </select>

                        <label>Seek Position</label>
                        <input type="range" id="gatesSeekPosition" min="0" max="100" value="0" step="0.1">
                        <div style="display: flex; justify-content: space-between; font-size: 12px; color: var(--text-muted);">
                            <span id="gatesSeekTime">0:00</span>
                            <span id="gatesVideoDuration">0:00</span>
                        </div>

                        <div style="margin-top: 8px;">
                            <input type="file" id="gatesVideoUploadInput" accept="video/*" style="display:none">
                            <button class="btn btn-outline btn-sm" id="gatesUploadVideo">Upload Test Video</button>
                            <div id="gatesUploadProgress" style="display:none; margin-top: 8px;">
                                <div style="background: var(--border); border-radius: 4px; height: 6px; overflow: hidden;">
                                    <div id="gatesUploadFill" style="background: var(--primary); height: 100%; width: 0%; transition: width 0.3s;"></div>
                                </div>
                                <span id="gatesUploadStatus" style="font-size: 12px; color: var(--text-muted);">Uploading...</span>
                            </div>
                        </div>
                    </div>

                    <button class="btn btn-primary" id="gatesGrabFrame" style="margin-top: 12px; width: 100%;">
                        Grab Frame
                    </button>
                </div>

                <!-- Card 2: Detection Settings -->
                <div class="card" id="gatesDetectionCard" style="display: none;">
                    <div class="card-title">2. Gate Detection</div>

                    <!-- GPS Section -->
                    <div class="gps-section" id="gpsSection">
                        <div class="gps-toggle-row" id="gpsToggleRow">
                            <label for="gpsEnable">
                                <span class="gps-status-dot" id="gpsStatusDot"></span>
                                GPS Mode (Bad Elf)
                            </label>
                            <input type="checkbox" id="gpsEnable" style="width: 18px; height: 18px;">
                        </div>
                        <div class="gps-body" id="gpsBody">
                            <div style="margin-bottom: 8px;">
                                <span style="color: var(--text-muted);">Live accuracy:</span>
                                <span class="gps-accuracy" id="gpsLiveAccuracy">—</span>
                            </div>
                            <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 10px;">
                                Camera Position
                                <span style="font-style: italic;">— stand at the camera, tap Capture</span>
                            </div>
                            <div class="gps-camera-row">
                                <button class="btn btn-sm btn-primary" id="gpsCaptureCamera">Capture Camera GPS</button>
                                <button class="btn btn-sm btn-outline" id="gpsLoadSaved" style="display: none;">Use Saved</button>
                            </div>
                            <div id="gpsCameraInfo" style="display: none; margin-top: 6px; font-size: 12px; color: var(--success);">
                                <span class="gps-status-dot captured"></span>
                                Camera: <span id="gpsCameraLat"></span>, <span id="gpsCameraLon"></span>
                                ±<span id="gpsCameraAcc"></span>m
                            </div>
                        </div>
                    </div>

                    <label for="gatesDiscipline" style="margin-top: 12px;">Discipline / Gate Type</label>
                    <select id="gatesDiscipline">
                        <option value="sl_youth">Slalom - Youth (U10-U12)</option>
                        <option value="sl_adult" selected>Slalom - Junior/Adult</option>
                        <option value="gs_panel">GS Panel</option>
                        <option value="sg_panel">Super-G Panel</option>
                    </select>

                    <div style="margin-top: 8px;">
                        <a href="#" id="gatesAdvancedToggle" style="font-size: 13px; color: var(--text-muted); text-decoration: none;">
                            Advanced Detection Settings <span id="gatesAdvancedArrow">&#9654;</span>
                        </a>
                        <div id="gatesAdvancedSettings" style="display: none; margin-top: 8px;">
                            <label>Min Gate Height (px): <span id="gatesMinHeightVal">30</span></label>
                            <input type="range" id="gatesMinHeight" min="10" max="200" value="30">
                            <label>Max Gate Height (px): <span id="gatesMaxHeightVal">800</span></label>
                            <input type="range" id="gatesMaxHeight" min="100" max="2000" value="800">
                            <label>Saturation Threshold: <span id="gatesSatThreshVal">120</span></label>
                            <input type="range" id="gatesSatThresh" min="50" max="255" value="120">
                            <label>Value Threshold: <span id="gatesValThreshVal">80</span></label>
                            <input type="range" id="gatesValThresh" min="30" max="255" value="80">
                        </div>
                    </div>

                    <button class="btn btn-primary" id="gatesDetectBtn" style="margin-top: 12px; width: 100%;">
                        Detect Gates
                    </button>
                </div>

                <!-- Card 3: Gate Review -->
                <div class="card" id="gatesReviewCard" style="display: none;">
                    <div class="card-title">3. Review & Adjust Gates</div>

                    <div id="gatesFrameContainer" style="position: relative; overflow: hidden; border-radius: 8px; background: #000; touch-action: none;">
                        <img id="gatesFrameImage" style="display: block; width: 100%; user-select: none; -webkit-user-drag: none;" draggable="false">
                        <!-- Gate pins are dynamically added here -->
                    </div>

                    <div style="display: flex; justify-content: space-between; align-items: center; margin-top: 8px;">
                        <div id="gatesCount" style="font-size: 14px; color: var(--text-muted);">
                            0 gates detected
                        </div>
                        <div style="display: flex; gap: 6px;">
                            <button class="btn btn-outline btn-sm" id="gatesAddBlueBtn" style="color: #2563eb; border-color: #2563eb;">+ Blue Gate</button>
                            <button class="btn btn-outline btn-sm" id="gatesAddRedBtn" style="color: #dc2626; border-color: #dc2626;">+ Red Gate</button>
                        </div>
                    </div>

                    <div id="gatesAddInstructions" style="display: none; margin-top: 8px; padding: 8px; background: #f0f9ff; border-radius: 6px; font-size: 13px;">
                        <span id="gatesAddInstructionText">Tap the <strong>top</strong> of the gate pole, then tap the <strong>base</strong>.</span>
                        <button class="btn btn-outline btn-sm" id="gatesCancelAdd" style="margin-left: 8px; font-size: 11px;">Cancel</button>
                    </div>

                    <div id="gatesMinWarning" style="display: none; margin-top: 8px; padding: 8px; background: #fef3c7; border-radius: 6px; font-size: 13px; color: #92400e;">
                        Need at least 4 gates for calibration.
                    </div>

                    <!-- GPS Walk Gates -->
                    <button class="btn btn-outline" id="gpsWalkGatesBtn" style="display: none; margin-top: 8px; width: 100%;">
                        Walk Gates for GPS
                    </button>
                    <div id="gpsGateSummary" class="gps-summary" style="display: none;">
                        <!-- Populated by JS after walking -->
                    </div>

                    <button class="btn btn-primary" id="gatesComputeBtn" style="margin-top: 12px; width: 100%;" disabled>
                        Compute Calibration
                    </button>
                </div>

                <!-- Card 4: Verification -->
                <div class="card" id="gatesVerifyCard" style="display: none;">
                    <div class="card-title">4. Verify Calibration</div>

                    <div style="border-radius: 8px; overflow: hidden; background: #000;">
                        <img id="gatesVerifyImage" style="display: block; width: 100%;">
                    </div>

                    <div style="margin-top: 8px; font-size: 14px;">
                        Reprojection Error: <strong id="gatesReprojError">—</strong> px
                        <span id="gatesReprojQuality" style="margin-left: 8px;"></span>
                        <br><span style="font-size: 12px; color: var(--text-muted);">Focal length: <span id="gatesFocalLength">—</span> px</span>
                    </div>
                    <div id="gatesPerGateErrors" style="display: none; margin-top: 6px; font-size: 12px; line-height: 1.6;"></div>

                    <div style="display: flex; gap: 8px; margin-top: 12px;">
                        <button class="btn btn-outline" id="gatesReadjustBtn" style="flex: 1;">
                            Re-adjust Gates
                        </button>
                        <button class="btn btn-primary" id="gatesAcceptBtn" style="flex: 1;">
                            Accept Calibration
                        </button>
                    </div>
                </div>

                <!-- Card 5: Calibration Status -->
                <div class="card" id="gatesStatusCard">
                    <div class="card-title">Calibration Status</div>
                    <div id="gatesStatusList" style="font-size: 14px; color: var(--text-muted);">
                        Loading...
                    </div>
                </div>
            </div><!-- end gatesMode -->

            <!-- ======= SESSION SETUP SUB-MODE ======= -->
            <div id="freeSkiMode">
            <!-- Active Session Warning (single, legacy) -->
            <div id="activeSession" class="active-session" style="display: none;">
                <div>
                    <strong>Active Session:</strong> <span id="activeSessionId"></span>
                    <br><small>Ends: <span id="activeSessionEnd"></span></small>
                </div>
        </div>

            <!-- Session Manager: all active/running sessions -->
            <div id="sessionManager" style="display: none; margin-bottom: 16px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="font-size: 14px;">Active Sessions</strong>
                    <button class="btn btn-outline btn-sm" onclick="refreshSessionManager()" style="font-size: 11px; padding: 3px 8px;">Refresh</button>
                </div>
                <div id="sessionManagerList"></div>
            </div>

        <!-- Calibration Badge (shown after accepting gate calibration) -->
        <div id="calibrationBadge" style="display: none; margin-bottom: 12px; padding: 10px 14px; background: #f0fdf4; border: 1px solid #86efac; border-radius: 8px; font-size: 14px;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <span style="color: #166534; font-weight: 600;">&#10003; Calibration Active</span>
                    <br><span id="calibrationBadgeInfo" style="font-size: 12px; color: #15803d;"></span>
                </div>
                <button class="btn btn-outline btn-sm" id="calibrationBadgeDismiss" style="font-size: 11px;">Dismiss</button>
            </div>
        </div>

        <!-- Status Messages -->
        <div id="status" class="status" style="display: none;"></div>

        <!-- Step 1: Camera Selection -->
        <div class="card">
            <div class="card-title">1. Select Source</div>
            <label for="sourceType">Input Type</label>
            <select id="sourceType">
                <option value="rtsp">Live Camera (RTSP)</option>
                <option value="video">Video File</option>
            </select>

            <div id="cameraSelect">
                <label for="camera">Camera</label>
                <select id="camera">
                    <option value="">Loading cameras...</option>
                </select>
                <div class="help-text" id="cameraOffsetInfo" style="display: none;">
                    Time offset: <span id="cameraOffsetPct">0</span>% into run
                </div>
            </div>

            <div id="videoSelect" style="display: none;">
                <label for="videoDropdown">Select Video</label>
                <select id="videoDropdown">
                    <option value="">Loading videos...</option>
                </select>
                <div id="videoInfo" style="display: none;">
                    <label for="seekTime">Seek to (seconds)</label>
                    <input type="range" id="seekTime" min="0" max="100" value="0">
                    <div class="help-text">Duration: <span id="videoDuration">0</span>s | Position: <span id="seekPosition">0</span>s</div>
                </div>

                <!-- Race Timing Section (appears for Video File only) -->
                <div id="volaSelect" style="margin-top: 16px; padding: 12px; background: #f0f9ff; border-radius: 8px; border: 1px solid #bfdbfe;">
                    <label style="font-weight: 600; color: #1e40af; margin-bottom: 8px; display: block;">Race Timing (Vola)</label>

                    <label for="volaFile" style="font-size: 13px;">Vola Excel File</label>
                    <select id="volaFile">
                        <option value="">-- None (manual detection) --</option>
                    </select>

                    <label for="startlistFile" style="margin-top: 8px; font-size: 13px;">Start List PDF (for names/teams)</label>
                    <select id="startlistFile">
                        <option value="">-- None (no names) --</option>
                    </select>
                    <div class="help-text">Adds athlete names and organizes by team folder</div>

                    <label for="volaRace" style="margin-top: 8px; font-size: 13px;">Race</label>
                    <select id="volaRace">
                        <option value="U12 run 1">U12 Run 1</option>
                        <option value="U12 run 2">U12 Run 2</option>
                        <option value="U14 run 1">U14 Run 1</option>
                        <option value="U14 run 2">U14 Run 2</option>
                    </select>

                    <label for="volaCamera" style="margin-top: 8px; font-size: 13px;">Camera Position</label>
                    <select id="volaCamera">
                        <option value="">Loading cameras...</option>
                    </select>
                    <div class="help-text" id="volaCameraOffsetInfo">
                        Time offset: <span id="volaCameraOffsetPct">0</span>% into run
                    </div>

                    <label for="volaView" style="margin-top: 8px; font-size: 13px;">View Number</label>
                    <select id="volaView" style="width: 100px;">
                        <option value="1">View 1</option>
                        <option value="2">View 2</option>
                        <option value="3">View 3</option>
                        <option value="4">View 4</option>
                        <option value="5">View 5</option>
                    </select>
                    <div class="help-text">For filename: Name_bib_runX_ViewY</div>

                    <label for="numAthletes" style="margin-top: 8px; font-size: 13px;">Number of Athletes</label>
                    <input type="number" id="numAthletes" min="0" max="100" value="5" style="width: 80px;">
                    <div class="help-text">Athletes to process (0 or blank = all)</div>

                    <button id="loadVolaData" class="btn btn-outline btn-sm" style="margin-top: 10px;">
                        Load Race Videos
                    </button>

                    <div id="volaRacersInfo" style="display: none; margin-top: 12px; padding: 10px; background: white; border-radius: 6px;">
                        <strong>Athletes:</strong> <span id="volaRacerCount">0</span> |
                        <strong>Videos:</strong> <span id="volaVideoCount">0</span>
                        <div class="help-text" style="margin-top: 4px;">
                            Time range: <span id="volaTimeRange">-</span>
                        </div>
                        <div class="help-text" style="margin-top: 2px;">
                            First: Bib <span id="volaFirstRacer">-</span> | Last: Bib <span id="volaLastRacer">-</span>
                        </div>
                    </div>
                </div>
            </div>

            <button id="grabFrame" class="btn btn-primary">
                Grab Frame
            </button>
        </div>

        <!-- Step 2: Frame & Zone Drawing -->
        <div class="card" id="frameCard" style="display: none;">
            <div class="card-title">2. Draw Trigger Zones</div>
            <p class="help-text" style="margin-bottom: 12px;">
                Draw START zone (green) at top where skiers enter, END zone (red) at bottom where they exit.
                Gates are between the two zones.
            </p>

            <div class="frame-wrapper" id="frameWrapper">
                <div class="frame-inner" id="frameInner">
                    <div class="frame-container" id="frameContainer">
                        <div class="frame-placeholder">No frame loaded</div>
                    </div>
                </div>
            </div>

            <div class="zoom-controls">
                <button class="zoom-btn" id="zoomOut">-</button>
                <button class="zoom-btn" id="zoomReset">1x</button>
                <button class="zoom-btn" id="zoomIn">+</button>
            </div>

            <div class="zone-buttons">
                <button class="zone-btn start" id="drawStart">Draw START Zone</button>
                <button class="zone-btn end" id="drawEnd">Draw END Zone</button>
                <button class="zone-btn crop" id="drawCrop">Draw CROP Area</button>
            </div>

            <!-- End Mode Toggle -->
            <div style="margin-top: 12px; padding: 12px; background: var(--bg); border-radius: 8px;">
                <label style="margin-bottom: 8px; display: block;">Run End Mode</label>
                <div class="end-mode-toggle">
                    <button type="button" class="end-mode-btn" id="endModeZone">END Zone</button>
                    <button type="button" class="end-mode-btn active" id="endModeDuration">Duration</button>
                </div>
                <div style="margin-top: 10px;">
                    <label for="runDuration" style="font-size: 13px;">Duration (seconds)</label>
                    <input type="number" id="runDuration" min="0.5" max="30" step="0.5" value="2" style="width: 100px;">
                    <span id="durationSetting" style="font-size: 12px; color: var(--text-muted); margin-left: 8px;">run capture length</span>
                </div>
                <div style="margin-top: 10px;">
                    <label style="font-size: 13px;">Montage FPS <span style="font-weight: normal; color: var(--text-muted);">(select multiple)</span></label>
                    <div class="fps-grid" id="fpsGrid">
                        <button type="button" class="fps-btn" data-fps="1.0">1.0</button>
                        <button type="button" class="fps-btn" data-fps="1.5">1.5</button>
                        <button type="button" class="fps-btn" data-fps="2.0">2.0</button>
                        <button type="button" class="fps-btn" data-fps="2.5">2.5</button>
                        <button type="button" class="fps-btn" data-fps="3.0">3.0</button>
                        <button type="button" class="fps-btn" data-fps="3.5">3.5</button>
                        <button type="button" class="fps-btn active" data-fps="4.0">4.0</button>
                        <button type="button" class="fps-btn" data-fps="4.5">4.5</button>
                        <button type="button" class="fps-btn" data-fps="5.0">5.0</button>
                        <button type="button" class="fps-btn" data-fps="5.5">5.5</button>
                        <button type="button" class="fps-btn" data-fps="6.0">6.0</button>
                        <button type="button" class="fps-btn" data-fps="6.5">6.5</button>
                        <button type="button" class="fps-btn" data-fps="7.0">7.0</button>
                        <button type="button" class="fps-btn" data-fps="7.5">7.5</button>
                        <button type="button" class="fps-btn" data-fps="8.0">8.0</button>
                        <button type="button" class="fps-btn" data-fps="8.5">8.5</button>
                        <button type="button" class="fps-btn" data-fps="9.0">9.0</button>
                        <button type="button" class="fps-btn" data-fps="9.5">9.5</button>
                        <button type="button" class="fps-btn" data-fps="10.0">10.0</button>
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <label for="startDelay" style="font-size: 13px;">Start Offset (sec)</label>
                    <input type="number" id="startDelay" min="0" max="10" step="0.1" value="0" style="width: 80px;">
                    <div class="help-text" style="margin-top: 4px;">Fixed delay in seconds after trigger before capturing. Same for all racers.</div>
                </div>
            </div>
        </div>

        <!-- Step 3: Session Config -->
        <div class="card" id="configCard" style="display: none;">
            <div class="card-title">3. Session Configuration</div>

            <label for="sessionType">Session Type</label>
            <select id="sessionType">
                <option value="test" selected>TEST</option>
                <option value="race">Race</option>
                <option value="gate_training">Gate Training</option>
                <option value="free_skiing">Free Skiing</option>
            </select>

            <label for="group">Group</label>
            <select id="group">
                <option value="U10">U10</option>
                <option value="U12">U12</option>
                <option value="U14">U14</option>
                <option value="Scored">Scored</option>
                <option value="Masters">Masters</option>
                <option value="Free Ski">Free Ski</option>
            </select>

            <div id="sessionEndTimeSection">
                <label for="endTime">Session End Time</label>
                <input type="datetime-local" id="endTime">
                <div class="help-text">Detection stops automatically at this time</div>
            </div>

            <div class="advanced-toggle" id="advancedToggle">
                <span>Advanced Settings</span>
                <span id="advancedArrow">&#9654;</span>
            </div>

            <div class="advanced-settings" id="advancedSettings">
                <label for="threshold">Detection Threshold</label>
                <input type="range" id="threshold" min="10" max="50" value="47">
                <div class="help-text">Current: <span id="thresholdValue">47</span></div>

                <label for="minPixels">Min Pixel Change %</label>
                <input type="range" id="minPixels" min="1" max="20" value="9" step="0.5">
                <div class="help-text">Current: <span id="minPixelsValue">9</span>%</div>

                <label for="minBrightness">Shadow Filter (Min Brightness)</label>
                <input type="range" id="minBrightness" min="0" max="200" value="94">
                <div class="help-text">Current: <span id="minBrightnessValue">94</span> (0=off, higher=filter more shadows)</div>

                <label for="preBuffer">Pre-buffer (seconds)</label>
                <input type="number" id="preBuffer" min="0" max="10" value="0">

                <label for="postBuffer">Post-buffer (seconds)</label>
                <input type="number" id="postBuffer" min="0" max="10" value="0">
            </div>
        </div>

        <!-- Save Button -->
        <div id="saveSection" style="display: none;">
            <button id="saveConfig" class="btn btn-success">
                Start Live Session
            </button>
        </div>

        <!-- Processing Status -->
        <div id="processingStatus" class="card" style="display: none;">
            <div class="card-title">Processing</div>
            <div id="processingInfo" style="margin-bottom: 12px;">
                <div style="color: var(--text-muted); font-size: 14px;">
                    Status: <span id="processingStatusText">Starting...</span>
                </div>
                <div style="color: var(--text-muted); font-size: 14px; margin-top: 4px;">
                    Runs detected: <span id="processingRuns">0</span>
                </div>
            </div>
        </div>

        <!-- Live Detection Metrics Chart -->
        <div id="metricsSection" style="display: none; margin-top: 20px; padding: 16px; background: var(--card-bg); border-radius: 8px; border: 1px solid var(--border);">
            <h3 style="margin: 0 0 12px 0; font-size: 16px; color: var(--text-primary);">Detection Metrics (Live)</h3>
            <canvas id="metricsCanvas" width="600" height="200" style="width: 100%; height: 200px; background: #1a1a2e; border-radius: 4px;"></canvas>
            <div style="display: flex; gap: 16px; margin-top: 8px; font-size: 12px; color: var(--text-secondary); flex-wrap: wrap;">
                <span><span style="display: inline-block; width: 12px; height: 3px; background: #22c55e; vertical-align: middle; margin-right: 4px;"></span>Start zone %</span>
                <span><span style="display: inline-block; width: 12px; height: 3px; background: #ef4444; vertical-align: middle; margin-right: 4px;"></span>End zone %</span>
                <span><span style="display: inline-block; width: 12px; height: 3px; background: #f59e0b; vertical-align: middle; margin-right: 4px; border-top: 2px dashed #f59e0b; height: 0;"></span>Threshold</span>
                <span><span style="display: inline-block; width: 12px; height: 12px; background: rgba(59,130,246,0.3); border: 1px solid #3b82f6; vertical-align: middle; margin-right: 4px;"></span>Run active</span>
            </div>
        </div>

        <!-- Stop Session (bottom of page) -->
        <div id="stopSessionSection" style="display: none; margin-top: 20px; padding-top: 16px; border-top: 1px solid var(--border);">
            <button id="stopSession" class="btn btn-danger" style="width: 100%; padding: 14px; font-size: 16px;">
                Stop Session
            </button>
        </div>
        </div><!-- end freeSkiMode -->
        </div><!-- end montageMode -->
    </div>

    <!-- Montage Fullscreen Overlay -->
    <div class="montage-overlay" id="montageOverlay">
        <img id="montageOverlayImg" src="">
    </div>

    <!-- Drawing Indicator -->
    <div class="drawing-indicator" id="drawingIndicator">
        Tap and drag to draw zone
    </div>

    <!-- GPS Walk Gates Overlay -->
    <div class="gps-walk-overlay" id="gpsWalkOverlay">
        <div class="gps-walk-gate-label" id="gpsWalkGateLabel">Gate 1 (red)</div>
        <div style="color: #94a3b8; font-size: 14px;">Walk to gate, wait for accuracy, tap Capture</div>
        <div class="gps-walk-accuracy" id="gpsWalkAccuracy">—</div>
        <div class="gps-walk-quality-bar">
            <div class="gps-walk-quality-fill" id="gpsWalkQualityFill" style="width: 0%; background: #ef4444;"></div>
        </div>
        <div class="gps-walk-buttons">
            <button class="btn btn-primary" id="gpsWalkCaptureBtn" style="background: #16a34a;">Capture</button>
            <button class="btn btn-outline" id="gpsWalkSkipBtn" style="color: white; border-color: #475569;">Skip</button>
        </div>
        <div class="gps-walk-dots" id="gpsWalkDots">
            <!-- Populated by JS -->
        </div>
        <div class="gps-walk-cancel" id="gpsWalkCancelBtn">Cancel Walk</div>
    </div>

    <script>
        // State
        let state = {
            mode: 'montage',  // 'montage' or 'stitch'
            montageSubMode: 'freeski',  // 'gates' or 'freeski'
            frameId: null,
            frameWidth: 0,
            frameHeight: 0,
            startZone: null,
            endZone: null,
            cropZone: null,
            drawingMode: null, // 'start', 'end', or 'crop'
            isDrawing: false,
            drawStart: { x: 0, y: 0 },
            zoom: 1,
            panX: 0,
            panY: 0,
            isPanning: false,
            panStart: { x: 0, y: 0 },
            panStartOffset: { x: 0, y: 0 },
            cameraId: null,
            cameraOffsetPct: 0,  // Camera time offset percentage
            endMode: 'duration',  // 'zone' or 'duration'
            runDurationSeconds: 2.0,
            montageFpsList: [4.0],
            startOffsetSec: 0,  // Fixed delay in seconds after trigger
            currentJobId: null,  // Track current processing job
            statusPollInterval: null,  // Interval for polling job status
            // Vola race timing data
            volaRacers: [],  // List of racers with timing data
            volaVideos: [],  // List of videos covering the race
            // Stitch mode state
            stitchRacers: [],
            stitchCuts: [],
            stitchVideoPaths: {},  // Auto-detected video paths for each camera
            stitchJobId: null,
            stitchPollInterval: null,
            volaRace: '',  // Selected race (e.g., "U12 run 1")
            volaCamera: '',  // Selected camera for Vola timing
            volaView: '1',  // View number 1-5 for filename
            startlistFile: '',  // Start list PDF file path (for racer names and teams)
            numAthletes: 5,  // Number of athletes to process (0 = all)
            raceDate: '',  // Date extracted from Vola file
            cameras: [],  // Camera list with offset percentages
            selectedLogos: [],  // List of selected logo filenames in order
            availableLogos: [],  // All available logos
            // Gates mode state
            gatesSourceType: 'rtsp',
            gatesFrameId: null,
            gatesFrameWidth: 0,
            gatesFrameHeight: 0,
            gates: [],
            gatesDiscipline: 'sl_adult',
            draggingPin: null,  // {gateIdx, point: 'top'|'base'}
            addGateMode: false,
            addGateTapCount: 0,  // 0=waiting for top, 1=waiting for base
            addGatePending: null,  // {top: [x,y]} while waiting for base tap
            addGateColor: null,   // 'red' or 'blue' — set when coach taps a color button
            gatesCalibrationId: null,
            gatesUploadedVideoPath: null,
            // Calibration context (set after gates Accept, used by saveConfig)
            activeCalibrationId: null,
            activeCalibrationDiscipline: null,
            activeCalibrationCameraId: null,
            // GPS state (Bad Elf GNSS)
            gpsEnabled: false,
            gpsCameraPosition: null,   // {lat, lon, alt, accuracy, timestamp}
            gpsGatePositions: {},      // gate index → {lat, lon, alt, accuracy, timestamp}
            gpsWatchId: null,          // from navigator.geolocation.watchPosition
            gpsCurrentReading: null,   // latest live GPS reading
            gpsWalkActive: false,      // walk-gates mode active
            gpsWalkGateList: [],       // ordered list of active gate indices
            gpsWalkCurrentIdx: 0,      // current position in walk list
        };

        // DOM Elements
        const elements = {
            sourceType: document.getElementById('sourceType'),
            cameraSelect: document.getElementById('cameraSelect'),
            camera: document.getElementById('camera'),
            videoSelect: document.getElementById('videoSelect'),
            videoDropdown: document.getElementById('videoDropdown'),
            seekPosition: document.getElementById('seekPosition'),
            videoInfo: document.getElementById('videoInfo'),
            seekTime: document.getElementById('seekTime'),
            videoDuration: document.getElementById('videoDuration'),
            grabFrame: document.getElementById('grabFrame'),
            frameCard: document.getElementById('frameCard'),
            frameWrapper: document.getElementById('frameWrapper'),
            frameInner: document.getElementById('frameInner'),
            frameContainer: document.getElementById('frameContainer'),
            drawStart: document.getElementById('drawStart'),
            drawEnd: document.getElementById('drawEnd'),
            drawCrop: document.getElementById('drawCrop'),
            drawingIndicator: document.getElementById('drawingIndicator'),
            configCard: document.getElementById('configCard'),
            sessionType: document.getElementById('sessionType'),
            group: document.getElementById('group'),
            endTime: document.getElementById('endTime'),
            advancedToggle: document.getElementById('advancedToggle'),
            advancedSettings: document.getElementById('advancedSettings'),
            advancedArrow: document.getElementById('advancedArrow'),
            threshold: document.getElementById('threshold'),
            thresholdValue: document.getElementById('thresholdValue'),
            minPixels: document.getElementById('minPixels'),
            minPixelsValue: document.getElementById('minPixelsValue'),
            minBrightness: document.getElementById('minBrightness'),
            minBrightnessValue: document.getElementById('minBrightnessValue'),
            preBuffer: document.getElementById('preBuffer'),
            postBuffer: document.getElementById('postBuffer'),
            saveSection: document.getElementById('saveSection'),
            saveConfig: document.getElementById('saveConfig'),
            status: document.getElementById('status'),
            calibrationBadge: document.getElementById('calibrationBadge'),
            calibrationBadgeInfo: document.getElementById('calibrationBadgeInfo'),
            calibrationBadgeDismiss: document.getElementById('calibrationBadgeDismiss'),
            activeSession: document.getElementById('activeSession'),
            activeSessionId: document.getElementById('activeSessionId'),
            activeSessionEnd: document.getElementById('activeSessionEnd'),
            stopSession: document.getElementById('stopSession'),
            stopSessionSection: document.getElementById('stopSessionSection'),
            sessionEndTimeSection: document.getElementById('sessionEndTimeSection'),
            zoomIn: document.getElementById('zoomIn'),
            zoomOut: document.getElementById('zoomOut'),
            zoomReset: document.getElementById('zoomReset'),
            endModeZone: document.getElementById('endModeZone'),
            endModeDuration: document.getElementById('endModeDuration'),
            runDuration: document.getElementById('runDuration'),
            montageFps: document.getElementById('montageFps'),
            startDelay: document.getElementById('startDelay'),
            processingStatus: document.getElementById('processingStatus'),
            processingStatusText: document.getElementById('processingStatusText'),
            processingRuns: document.getElementById('processingRuns'),
            // Vola elements
            volaSelect: document.getElementById('volaSelect'),
            volaFile: document.getElementById('volaFile'),
            startlistFile: document.getElementById('startlistFile'),
            volaRace: document.getElementById('volaRace'),
            volaCamera: document.getElementById('volaCamera'),
            volaView: document.getElementById('volaView'),
            volaCameraOffsetInfo: document.getElementById('volaCameraOffsetInfo'),
            volaCameraOffsetPct: document.getElementById('volaCameraOffsetPct'),
            volaRacersInfo: document.getElementById('volaRacersInfo'),
            volaRacerCount: document.getElementById('volaRacerCount'),
            volaFirstRacer: document.getElementById('volaFirstRacer'),
            volaLastRacer: document.getElementById('volaLastRacer'),
            loadVolaData: document.getElementById('loadVolaData'),
            cameraOffsetInfo: document.getElementById('cameraOffsetInfo'),
            cameraOffsetPct: document.getElementById('cameraOffsetPct'),
            numAthletes: document.getElementById('numAthletes'),
            volaVideoCount: document.getElementById('volaVideoCount'),
            volaTimeRange: document.getElementById('volaTimeRange'),
            // Mode selection
            modeCalibration: document.getElementById('modeCalibration'),
            modeGallery: document.getElementById('modeGallery'),
            modeStitch: document.getElementById('modeStitch'),
            montageMode: document.getElementById('montageMode'),
            galleryMode: document.getElementById('galleryMode'),
            stitchMode: document.getElementById('stitchMode'),
            // Sub-mode elements (inside Photo Montage)
            subModeGates: document.getElementById('subModeGates'),
            subModeFreeSki: document.getElementById('subModeFreeSki'),
            gatesMode: document.getElementById('gatesMode'),
            freeSkiMode: document.getElementById('freeSkiMode'),
            // Stitch elements
            stitchVolaFile: document.getElementById('stitchVolaFile'),
            stitchStartlistFile: document.getElementById('stitchStartlistFile'),
            stitchResultsFile: document.getElementById('stitchResultsFile'),
            stitchRace: document.getElementById('stitchRace'),
            // Race info fields
            raceInfoEvent: document.getElementById('raceInfoEvent'),
            raceInfoDiscipline: document.getElementById('raceInfoDiscipline'),
            raceInfoAgeGroup: document.getElementById('raceInfoAgeGroup'),
            raceInfoRun: document.getElementById('raceInfoRun'),
            raceInfoDate: document.getElementById('raceInfoDate'),
            raceInfoType: document.getElementById('raceInfoType'),
            raceInfoCourse: document.getElementById('raceInfoCourse'),
            raceInfoLocation: document.getElementById('raceInfoLocation'),
            raceInfoVertical: document.getElementById('raceInfoVertical'),
            raceInfoLength: document.getElementById('raceInfoLength'),
            raceInfoGates: document.getElementById('raceInfoGates'),
            raceInfoSnow: document.getElementById('raceInfoSnow'),
            logoList: document.getElementById('logoList'),
            stitchGenerateComparison: document.getElementById('stitchGenerateComparison'),
            stitchTestCount: document.getElementById('stitchTestCount'),
            stitchPreBuffer: document.getElementById('stitchPreBuffer'),
            stitchPostBuffer: document.getElementById('stitchPostBuffer'),
            stitchLoadRacers: document.getElementById('stitchLoadRacers'),
            stitchRacersInfo: document.getElementById('stitchRacersInfo'),
            stitchRacerCount: document.getElementById('stitchRacerCount'),
            stitchRacersTable: document.getElementById('stitchRacersTable'),
            stitchCutsCard: document.getElementById('stitchCutsCard'),
            stitchConfigSelect: document.getElementById('stitchConfigSelect'),
            stitchCutR1Start: document.getElementById('stitchCutR1Start'),
            stitchCutR1End: document.getElementById('stitchCutR1End'),
            stitchCutAxisStart: document.getElementById('stitchCutAxisStart'),
            stitchCutAxisEnd: document.getElementById('stitchCutAxisEnd'),
            stitchCutR2Start: document.getElementById('stitchCutR2Start'),
            stitchCutR2End: document.getElementById('stitchCutR2End'),
            stitchCutR3Start: document.getElementById('stitchCutR3Start'),
            stitchCutR3End: document.getElementById('stitchCutR3End'),
            stitchConfigName: document.getElementById('stitchConfigName'),
            stitchSaveConfig: document.getElementById('stitchSaveConfig'),
            stitchVideosCard: document.getElementById('stitchVideosCard'),
            stitchVideoR1Display: document.getElementById('stitchVideoR1Display'),
            stitchVideoAxisDisplay: document.getElementById('stitchVideoAxisDisplay'),
            stitchVideoR2Display: document.getElementById('stitchVideoR2Display'),
            stitchVideoR3Display: document.getElementById('stitchVideoR3Display'),
            stitchVideosMissing: document.getElementById('stitchVideosMissing'),
            stitchProcessCard: document.getElementById('stitchProcessCard'),
            stitchProcessLocation: document.getElementById('stitchProcessLocation'),
            localProcessingControls: document.getElementById('localProcessingControls'),
            serverProcessingControls: document.getElementById('serverProcessingControls'),
            stitchStartProcess: document.getElementById('stitchStartProcess'),
            stitchStopProcess: document.getElementById('stitchStopProcess'),
            stitchGenerateCommand: document.getElementById('stitchGenerateCommand'),
            serverCommandOutput: document.getElementById('serverCommandOutput'),
            serverCommandText: document.getElementById('serverCommandText'),
            copyServerCommand: document.getElementById('copyServerCommand'),
            stitchProgress: document.getElementById('stitchProgress'),
            stitchProgressBar: document.getElementById('stitchProgressBar'),
            stitchProgressText: document.getElementById('stitchProgressText'),
            stitchCurrentRacer: document.getElementById('stitchCurrentRacer'),
            stitchResults: document.getElementById('stitchResults'),
            stitchOutputDir: document.getElementById('stitchOutputDir'),
            stitchOutputCount: document.getElementById('stitchOutputCount'),
            stitchError: document.getElementById('stitchError'),
        };

        // Initialize
        async function init() {
            await loadCameras();
            await loadVideos();
            await loadVolaFiles();
            setDefaultEndTime();
            setupEventListeners();
            // Set initial end mode (hides END zone button if in duration mode)
            setEndMode(state.endMode);
            // Only check active session for RTSP mode (check after setup so UI is correct)
            if (elements.sourceType.value === 'rtsp') {
                await checkActiveSession();
            } else {
                // Always show session manager even in non-RTSP mode
                refreshSessionManager();
            }
            // Default to Gates sub-mode within Photo Montage
            switchSubMode('gates');
        }

        async function loadVideos() {
            try {
                const res = await fetch('/api/videos');
                const videos = await res.json();
                if (videos.length === 0) {
                    elements.videoDropdown.innerHTML = '<option value="">No videos found</option>';
                    return;
                }
                elements.videoDropdown.innerHTML = videos.map(v =>
                    `<option value="${v.path}">${v.name} (${v.duration}s, ${v.resolution}, ${v.size_mb}MB)</option>`
                ).join('');
                // Auto-select first video and load its info
                if (videos.length > 0) {
                    loadVideoInfo(videos[0].path);
                }
            } catch (e) {
                elements.videoDropdown.innerHTML = '<option value="">Failed to load videos</option>';
            }
        }

        async function loadVideoInfo(videoPath) {
            if (!videoPath) return;
            try {
                const res = await fetch('/api/video/info', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ video_path: videoPath })
                });
                const info = await res.json();
                if (info.duration) {
                    elements.videoInfo.style.display = 'block';
                    elements.seekTime.max = Math.floor(info.duration);
                    elements.seekTime.value = 0;
                    elements.videoDuration.textContent = Math.floor(info.duration);
                    elements.seekPosition.textContent = '0';
                }
            } catch (e) {
                console.error('Failed to get video info:', e);
            }
        }

        async function loadCameras() {
            try {
                const res = await fetch('/api/cameras');
                const cameras = await res.json();
                state.cameras = cameras;

                // Populate main camera dropdown
                elements.camera.innerHTML = cameras.map(c =>
                    `<option value="${c.id}" data-offset="${c.offset_pct}">${c.name}</option>`
                ).join('');

                // Populate Vola camera dropdown
                elements.volaCamera.innerHTML = cameras.map(c =>
                    `<option value="${c.id}" data-offset="${c.offset_pct}">${c.name}</option>`
                ).join('');

                if (cameras.length > 0) {
                    state.cameraId = cameras[0].id;
                    state.cameraOffsetPct = cameras[0].offset_pct || 0;
                    state.volaCamera = cameras[0].id;
                    updateCameraOffsetDisplay();
                }
            } catch (e) {
                showStatus('Failed to load cameras', 'error');
            }
        }

        function updateCameraOffsetDisplay() {
            const camera = state.cameras.find(c => c.id === state.cameraId);
            if (camera) {
                elements.cameraOffsetPct.textContent = camera.offset_pct || 0;
                elements.cameraOffsetInfo.style.display = 'block';
            }
            const volaCamera = state.cameras.find(c => c.id === state.volaCamera);
            if (volaCamera) {
                elements.volaCameraOffsetPct.textContent = volaCamera.offset_pct || 0;
            }
        }

        async function loadVolaFiles() {
            try {
                // Load Vola Excel files
                const res = await fetch('/api/vola/files');
                const files = await res.json();
                if (files.length === 0) {
                    elements.volaFile.innerHTML = '<option value="">No Vola files found</option>';
                } else {
                    elements.volaFile.innerHTML = files.map(f =>
                        `<option value="${f.path}">${f.name}</option>`
                    ).join('');
                }

                // Load Start List PDF files
                const resStartlist = await fetch('/api/vola/startlist-files');
                const startlistFiles = await resStartlist.json();
                elements.startlistFile.innerHTML = '<option value="">-- None (no names) --</option>';
                if (startlistFiles.length > 0) {
                    elements.startlistFile.innerHTML += startlistFiles.map(f =>
                        `<option value="${f.path}">${f.name}</option>`
                    ).join('');
                }
            } catch (e) {
                elements.volaFile.innerHTML = '<option value="">Failed to load files</option>';
            }
        }

        async function loadVolaData() {
            const filePath = elements.volaFile.value;
            const startlistFilePath = elements.startlistFile.value;
            const race = elements.volaRace.value;
            const cameraId = elements.volaCamera.value;
            const numAthletes = parseInt(elements.numAthletes.value) || 0;

            if (!filePath) {
                showStatus('Please select a Vola file', 'error');
                return;
            }

            elements.loadVolaData.innerHTML = '<span class="spinner"></span>Loading...';
            elements.loadVolaData.disabled = true;

            try {
                // Use the new API that returns both racers and matching videos
                const res = await fetch('/api/recordings/videos-for-race', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        vola_file: filePath,
                        startlist_file: startlistFilePath || null,  // Optional: PDF with racer names and teams
                        race: race,
                        camera_id: cameraId,
                        num_athletes: numAthletes,
                    })
                });

                const data = await res.json();
                if (data.error) {
                    showStatus(`Error: ${data.error}`, 'error');
                    return;
                }

                // Store data in state
                state.volaRacers = data.racers;
                state.volaVideos = data.videos;
                state.volaRace = race;
                state.volaCamera = cameraId;
                state.numAthletes = numAthletes;
                state.raceDate = data.date;

                // Update UI
                elements.volaRacersInfo.style.display = 'block';
                elements.volaRacerCount.textContent = data.num_athletes;
                elements.volaVideoCount.textContent = data.videos.length;
                elements.volaTimeRange.textContent = `${data.time_range.start_str} - ${data.time_range.end_str}`;

                if (data.racers.length > 0) {
                    elements.volaFirstRacer.textContent = data.racers[0].bib;
                    elements.volaLastRacer.textContent = data.racers[data.racers.length - 1].bib;
                }

                // Auto-select first video in dropdown for calibration
                if (data.videos.length > 0) {
                    // Update video dropdown with matching videos
                    elements.videoDropdown.innerHTML = data.videos.map(v =>
                        `<option value="${v.path}">${v.name} (${v.start_time_str} - ${v.end_time_str})</option>`
                    ).join('');
                    elements.videoDropdown.dispatchEvent(new Event('change'));
                }

                showStatus(`Found ${data.num_athletes} athletes, ${data.videos.length} videos`, 'success');

            } catch (e) {
                showStatus('Failed to load race data: ' + e.message, 'error');
            } finally {
                elements.loadVolaData.innerHTML = 'Load Race Videos';
                elements.loadVolaData.disabled = false;
            }
        }

        async function checkActiveSession() {
            // Only check/show active session for RTSP mode
            if (elements.sourceType.value !== 'rtsp') {
                elements.activeSession.style.display = 'none';
                return;
            }

            try {
                const res = await fetch('/api/config/active');
                const data = await res.json();
                if (data.active) {
                    elements.activeSession.style.display = 'block';
                    elements.stopSessionSection.style.display = 'block';
                    elements.activeSessionId.textContent = data.config.session_id;
                    elements.activeSessionEnd.textContent = new Date(data.config.session_end_time).toLocaleTimeString();
                } else {
                    elements.activeSession.style.display = 'none';
                }
            } catch (e) {
                console.error('Failed to check active session:', e);
            }

            // Also refresh the session manager
            refreshSessionManager();
        }

        async function refreshSessionManager() {
            const mgr = document.getElementById('sessionManager');
            const list = document.getElementById('sessionManagerList');
            if (!mgr || !list) return;

            try {
                const res = await fetch('/api/config/all_active');
                const data = await res.json();
                const sessions = data.sessions || [];

                // Restore currentJobId from running session if not already set
                if (!state.currentJobId) {
                    const running = sessions.find(s => s.is_running && s.job_id);
                    if (running) {
                        state.currentJobId = running.job_id;
                        startMetricsPolling();
                        startStatusPolling();
                    }
                }

                if (sessions.length === 0) {
                    mgr.style.display = 'none';
                    return;
                }

                mgr.style.display = 'block';
                list.innerHTML = sessions.map(s => {
                    const c = s.config;
                    const endStr = c.session_end_time
                        ? new Date(c.session_end_time).toLocaleTimeString()
                        : 'Unknown';
                    const startStr = c.session_start_time
                        ? new Date(c.session_start_time).toLocaleTimeString()
                        : '';
                    const statusBadge = s.is_running
                        ? '<span style="color: #16a34a; font-weight: 600;">&#9679; Running</span>'
                        : '<span style="color: #d97706; font-weight: 600;">&#9679; Scheduled</span>';
                    const camera = c.camera_id || '';
                    const group = c.group || '';
                    const type = c.session_type || '';
                    const label = [group, type, camera].filter(Boolean).join(' \u2022 ');

                    return `
                        <div style="display: flex; justify-content: space-between; align-items: center;
                                    padding: 10px 12px; margin-bottom: 6px;
                                    background: ${s.is_running ? '#fefce8' : '#f8fafc'};
                                    border: 1px solid ${s.is_running ? '#fde68a' : '#e2e8f0'};
                                    border-radius: 8px; font-size: 13px;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    ${statusBadge} &nbsp;${label}
                                </div>
                                <div style="color: #64748b; font-size: 12px; margin-top: 2px;">
                                    ${startStr ? startStr + ' \u2013 ' : ''}${endStr}
                                </div>
                                <div style="color: #94a3b8; font-size: 11px; margin-top: 1px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">
                                    ${c.session_id}
                                </div>
                            </div>
                            <button class="btn btn-danger btn-sm"
                                    onclick="stopSessionById('${c.session_id}', this)"
                                    style="margin-left: 10px; padding: 5px 12px; font-size: 12px; white-space: nowrap;">
                                Stop
                            </button>
                        </div>
                    `;
                }).join('');
            } catch (e) {
                console.error('Failed to load sessions:', e);
            }
        }

        async function stopSessionById(sessionId, btn) {
            if (!confirm('Stop session ' + sessionId + '?')) return;
            const origText = btn.innerHTML;
            btn.innerHTML = '<span class="spinner"></span>';
            btn.disabled = true;

            try {
                const res = await fetch('/api/config/stop/' + sessionId, { method: 'POST' });
                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    btn.innerHTML = origText;
                    btn.disabled = false;
                    return;
                }
                showStatus('Session stopped: ' + sessionId, 'success');
                // Refresh both views
                refreshSessionManager();
                checkActiveSession();
            } catch (e) {
                showStatus('Failed to stop: ' + e.message, 'error');
                btn.innerHTML = origText;
                btn.disabled = false;
            }
        }

        function setDefaultEndTime() {
            const now = new Date();
            now.setMinutes(now.getMinutes() + 90);
            const local = new Date(now.getTime() - now.getTimezoneOffset() * 60000);
            elements.endTime.value = local.toISOString().slice(0, 16);
        }

        function setupEventListeners() {
            // Source type toggle
            elements.sourceType.addEventListener('change', () => {
                const sourceType = elements.sourceType.value;
                const isRtsp = sourceType === 'rtsp';
                const isVideo = sourceType === 'video';

                // Show/hide source-specific sections
                elements.cameraSelect.style.display = isRtsp ? 'block' : 'none';
                elements.videoSelect.style.display = isVideo ? 'block' : 'none';

                // Show/hide session end time (only for RTSP live streams)
                elements.sessionEndTimeSection.style.display = isRtsp ? 'block' : 'none';

                // Show/hide active session banner (only for RTSP)
                if (!isRtsp) {
                    elements.activeSession.style.display = 'none';
                } else {
                    checkActiveSession();
                }

                // Update button text based on source type
                updateSaveButtonText();
            });

            elements.camera.addEventListener('change', () => {
                state.cameraId = elements.camera.value;
                const camera = state.cameras.find(c => c.id === state.cameraId);
                if (camera) {
                    state.cameraOffsetPct = camera.offset_pct || 0;
                }
                updateCameraOffsetDisplay();
            });

            // Vola camera change
            elements.volaCamera.addEventListener('change', () => {
                state.volaCamera = elements.volaCamera.value;
                updateCameraOffsetDisplay();
            });

            // Vola view change
            elements.volaView.addEventListener('change', () => {
                state.volaView = elements.volaView.value;
            });

            // Vola race change - reload data if we have a file selected
            elements.volaRace.addEventListener('change', () => {
                if (elements.volaFile.value && state.volaRacers.length > 0) {
                    loadVolaData();
                }
            });

            // Load Vola data button
            elements.loadVolaData.addEventListener('click', loadVolaData);

            // Video dropdown change - load video info
            elements.videoDropdown.addEventListener('change', () => {
                loadVideoInfo(elements.videoDropdown.value);
            });

            // Seek time change - update position display
            elements.seekTime.addEventListener('input', () => {
                elements.seekPosition.textContent = elements.seekTime.value;
            });

            // Frame grabbing
            elements.grabFrame.addEventListener('click', grabFrame);

            // Zone drawing buttons
            elements.drawStart.addEventListener('click', () => toggleDrawMode('start'));
            elements.drawEnd.addEventListener('click', () => toggleDrawMode('end'));
            elements.drawCrop.addEventListener('click', () => toggleDrawMode('crop'));

            // End mode toggle (buttons)
            elements.endModeZone.addEventListener('click', () => setEndMode('zone'));
            elements.endModeDuration.addEventListener('click', () => setEndMode('duration'));
            elements.runDuration.addEventListener('change', () => {
                state.runDurationSeconds = parseFloat(elements.runDuration.value) || 2.0;
            });
            document.querySelectorAll('.fps-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    btn.classList.toggle('active');
                    // Collect all active FPS values
                    const selected = [];
                    document.querySelectorAll('.fps-btn.active').forEach(b => {
                        selected.push(parseFloat(b.dataset.fps));
                    });
                    selected.sort((a, b) => a - b);
                    state.montageFpsList = selected.length > 0 ? selected : [4.0];
                });
            });
            elements.startDelay.addEventListener('change', () => {
                state.startOffsetSec = parseFloat(elements.startDelay.value) || 0;
            });

            // Advanced settings toggle
            elements.advancedToggle.addEventListener('click', () => {
                elements.advancedSettings.classList.toggle('visible');
                elements.advancedArrow.textContent = elements.advancedSettings.classList.contains('visible') ? '▼' : '▶';
            });

            // Sliders — update display + send live updates if session active
            let liveUpdateTimer = null;
            function debouncedLiveUpdate() {
                if (liveUpdateTimer) clearTimeout(liveUpdateTimer);
                liveUpdateTimer = setTimeout(sendLiveSettingsUpdate, 300);
            }

            elements.threshold.addEventListener('input', () => {
                elements.thresholdValue.textContent = elements.threshold.value;
                debouncedLiveUpdate();
            });
            elements.minPixels.addEventListener('input', () => {
                elements.minPixelsValue.textContent = elements.minPixels.value;
                debouncedLiveUpdate();
            });
            elements.minBrightness.addEventListener('input', () => {
                elements.minBrightnessValue.textContent = elements.minBrightness.value;
                debouncedLiveUpdate();
            });

            // Zoom controls
            elements.zoomIn.addEventListener('click', () => setZoom(state.zoom * 1.5));
            elements.zoomOut.addEventListener('click', () => setZoom(state.zoom / 1.5));
            elements.zoomReset.addEventListener('click', () => setZoom(1));

            // Save config
            elements.saveConfig.addEventListener('click', saveConfig);

            // Stop session (unified — stops config + kills process)
            elements.stopSession.addEventListener('click', stopSession);

            // Calibration badge dismiss
            elements.calibrationBadgeDismiss.addEventListener('click', dismissCalibrationBadge);
        }

        async function sendLiveSettingsUpdate() {
            const sessionId = elements.activeSessionId.textContent;
            if (!sessionId) return; // No active session, nothing to update

            const payload = {
                detection_threshold: parseInt(elements.threshold.value),
                min_pixel_change_pct: parseFloat(elements.minPixels.value),
                min_brightness: parseInt(elements.minBrightness.value),
            };

            try {
                const res = await fetch(`/api/config/update_live/${sessionId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload),
                });
                const data = await res.json();

                if (data.error) {
                    showStatus(`Live update failed: ${data.error}`, 'error');
                    return;
                }

                if (data.changed && data.changed.length > 0) {
                    // Brief green flash feedback — don't use showStatus to avoid hiding important messages
                    const flashEl = document.createElement('div');
                    flashEl.textContent = '✓ Settings applied';
                    flashEl.style.cssText = 'position:fixed;top:10px;right:10px;background:#28a745;color:#fff;padding:6px 14px;border-radius:6px;font-size:13px;z-index:9999;opacity:1;transition:opacity 0.5s';
                    document.body.appendChild(flashEl);
                    setTimeout(() => { flashEl.style.opacity = '0'; }, 1200);
                    setTimeout(() => { flashEl.remove(); }, 1800);
                }
            } catch (err) {
                console.error('Live settings update failed:', err);
            }
        }

        async function stopSession() {
            const sessionId = elements.activeSessionId.textContent;
            if (!sessionId) {
                showStatus('No active session to stop', 'error');
                return;
            }

            elements.stopSession.innerHTML = '<span class="spinner"></span>Stopping...';
            elements.stopSession.disabled = true;

            try {
                // Single call — backend stops config AND kills process
                const res = await fetch(`/api/config/stop/${sessionId}`, { method: 'POST' });
                const data = await res.json();

                if (data.error) {
                    showStatus(data.error, 'error');
                    elements.stopSession.innerHTML = 'Stop Session';
                    elements.stopSession.disabled = false;
                    return;
                }

                showStatus('Session stopped', 'success');
                elements.activeSession.style.display = 'none';
                elements.stopSessionSection.style.display = 'none';
                elements.processingStatus.style.display = 'none';
                state.currentJobId = null;
            } catch (e) {
                showStatus('Failed to stop session: ' + e.message, 'error');
                elements.stopSession.innerHTML = 'Stop Session';
                elements.stopSession.disabled = false;
            }
        }

        async function grabFrame() {
            elements.grabFrame.innerHTML = '<span class="spinner"></span>Loading...';
            elements.grabFrame.disabled = true;

            try {
                const isVideo = elements.sourceType.value === 'video';
                console.log('grabFrame: sourceType =', elements.sourceType.value);
                console.log('grabFrame: videoDropdown.value =', elements.videoDropdown.value);

                // Validate video path before making request
                if (isVideo && !elements.videoDropdown.value) {
                    showStatus('Please select a video first', 'error');
                    elements.grabFrame.innerHTML = 'Grab Frame';
                    elements.grabFrame.disabled = false;
                    return;
                }

                const body = !isVideo
                    ? { source_type: 'rtsp', camera_id: state.cameraId }
                    : {
                        source_type: 'video',
                        video_path: elements.videoDropdown.value,
                        seek_seconds: parseInt(elements.seekTime.value) || 0
                    };
                console.log('grabFrame: body =', body);

                const res = await fetch('/api/frame/grab', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body)
                });

                const data = await res.json();

                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                state.frameId = data.frame_id;
                state.frameWidth = data.width;
                state.frameHeight = data.height;

                // Display frame
                elements.frameContainer.innerHTML = `<img src="${data.url}" alt="Calibration frame" id="frameImage">`;
                elements.frameCard.style.display = 'block';
                elements.configCard.style.display = 'block';
                elements.saveSection.style.display = 'block';

                // Setup drawing handlers
                setupDrawingHandlers();

                showStatus('Frame captured! Draw START and END zones.', 'success');

            } catch (e) {
                showStatus('Failed to grab frame: ' + e.message, 'error');
            } finally {
                elements.grabFrame.innerHTML = 'Grab Frame';
                elements.grabFrame.disabled = false;
            }
        }

        let drawingHandlersAttached = false;
        function setupDrawingHandlers() {
            if (drawingHandlersAttached) return;
            drawingHandlersAttached = true;
            const container = elements.frameContainer;

            // Mouse events
            container.addEventListener('mousedown', onDrawStart);
            container.addEventListener('mousemove', onDrawMove);
            container.addEventListener('mouseup', onDrawEnd);
            container.addEventListener('mouseleave', onDrawEnd);

            // Touch events
            container.addEventListener('touchstart', onDrawStart, { passive: false });
            container.addEventListener('touchmove', onDrawMove, { passive: false });
            container.addEventListener('touchend', onDrawEnd);
        }

        function toggleDrawMode(mode) {
            if (state.drawingMode === mode) {
                state.drawingMode = null;
                elements.drawStart.classList.remove('active');
                elements.drawEnd.classList.remove('active');
                elements.drawCrop.classList.remove('active');
                elements.drawingIndicator.classList.remove('visible');
                elements.frameContainer.classList.remove('drawing-active');
            } else {
                state.drawingMode = mode;
                elements.drawStart.classList.toggle('active', mode === 'start');
                elements.drawEnd.classList.toggle('active', mode === 'end');
                elements.drawCrop.classList.toggle('active', mode === 'crop');
                const label = mode === 'crop' ? 'CROP area' : `${(mode || '').toUpperCase()} zone`;
                elements.drawingIndicator.textContent = `Tap and drag to draw ${label}`;
                elements.drawingIndicator.classList.add('visible');
                elements.frameContainer.classList.add('drawing-active');
            }
        }

        function setEndMode(mode) {
            state.endMode = mode;
            // Update button states
            elements.endModeZone.classList.toggle('active', mode === 'zone');
            elements.endModeDuration.classList.toggle('active', mode === 'duration');
            // Show/hide END zone button based on mode (Duration is always visible)
            elements.drawEnd.style.display = mode === 'zone' ? 'inline-block' : 'none';
            // Clear END zone if switching to duration mode
            if (state.endMode === 'duration') {
                state.endZone = null;
                renderZones();
            }
        }

        function getEventCoords(e) {
            const rect = elements.frameContainer.getBoundingClientRect();
            const img = document.getElementById('frameImage');
            if (!img) return null;

            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            // Account for zoom and pan
            const displayWidth = img.clientWidth;
            const displayHeight = img.clientHeight;

            const x = ((clientX - rect.left) / displayWidth) * state.frameWidth / state.zoom;
            const y = ((clientY - rect.top) / displayHeight) * state.frameHeight / state.zoom;

            return { x: Math.round(x), y: Math.round(y) };
        }

        function onDrawStart(e) {
            // If not in drawing mode and zoomed in, start panning
            if (!state.drawingMode) {
                if (state.zoom > 1) {
                    e.preventDefault();
                    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                    state.isPanning = true;
                    state.panStart = { x: clientX, y: clientY };
                    state.panStartOffset = { x: state.panX, y: state.panY };
                    elements.frameContainer.style.cursor = 'grabbing';
                }
                return;
            }
            e.preventDefault();

            const coords = getEventCoords(e);
            if (!coords) return;

            state.isDrawing = true;
            state.drawStart = coords;
        }

        function onDrawMove(e) {
            // Handle panning
            if (state.isPanning) {
                e.preventDefault();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                const dx = clientX - state.panStart.x;
                const dy = clientY - state.panStart.y;
                state.panX = state.panStartOffset.x + dx;
                state.panY = state.panStartOffset.y + dy;
                applyTransform();
                return;
            }

            if (!state.isDrawing || !state.drawingMode) return;
            e.preventDefault();

            const coords = getEventCoords(e);
            if (!coords) return;

            const zone = {
                x: Math.min(state.drawStart.x, coords.x),
                y: Math.min(state.drawStart.y, coords.y),
                w: Math.abs(coords.x - state.drawStart.x),
                h: Math.abs(coords.y - state.drawStart.y)
            };

            if (state.drawingMode === 'start') {
                state.startZone = zone;
            } else if (state.drawingMode === 'end') {
                state.endZone = zone;
            } else if (state.drawingMode === 'crop') {
                state.cropZone = zone;
            }

            renderZones();
        }

        function onDrawEnd(e) {
            if (state.isPanning) {
                state.isPanning = false;
                elements.frameContainer.style.cursor = '';
                return;
            }
            if (!state.isDrawing) return;

            state.isDrawing = false;

            // Auto-advance to next zone (but not from crop)
            // Only auto-advance to END zone if in zone mode (not duration mode)
            if (state.drawingMode === 'start' && state.startZone && !state.endZone && state.endMode === 'zone') {
                toggleDrawMode('end');
            } else if (state.drawingMode === 'end' && state.endZone) {
                toggleDrawMode(null);
            } else if (state.drawingMode === 'crop') {
                toggleDrawMode(null);
            } else if (state.drawingMode === 'start' && state.startZone && state.endMode === 'duration') {
                // In duration mode, just clear drawing mode after START zone
                toggleDrawMode(null);
            }

            checkReadyToSave();
        }

        function renderZones() {
            // Remove existing overlays
            document.querySelectorAll('.zone-overlay').forEach(el => el.remove());

            const img = document.getElementById('frameImage');
            if (!img) return;

            const displayWidth = img.clientWidth;
            const displayHeight = img.clientHeight;
            // Zone overlays are inside frameContainer which is inside the scaled frameInner,
            // so use unscaled ratios — the CSS transform handles the zoom visually
            const scaleX = displayWidth / state.frameWidth;
            const scaleY = displayHeight / state.frameHeight;

            if (state.startZone) {
                const overlay = createZoneOverlay(state.startZone, 'start', 'START', scaleX, scaleY);
                elements.frameContainer.appendChild(overlay);
            }

            if (state.endZone) {
                const overlay = createZoneOverlay(state.endZone, 'end', 'END', scaleX, scaleY);
                elements.frameContainer.appendChild(overlay);
            }

            if (state.cropZone) {
                const overlay = createZoneOverlay(state.cropZone, 'crop', 'CROP', scaleX, scaleY);
                elements.frameContainer.appendChild(overlay);
            }
        }

        function createZoneOverlay(zone, type, label, scaleX, scaleY) {
            const overlay = document.createElement('div');
            overlay.className = `zone-overlay ${type}`;
            overlay.style.left = `${zone.x * scaleX}px`;
            overlay.style.top = `${zone.y * scaleY}px`;
            overlay.style.width = `${zone.w * scaleX}px`;
            overlay.style.height = `${zone.h * scaleY}px`;

            const labelEl = document.createElement('span');
            labelEl.className = 'zone-label';
            labelEl.textContent = label;
            overlay.appendChild(labelEl);

            return overlay;
        }

        function applyTransform() {
            elements.frameInner.style.transform = `translate(${state.panX}px, ${state.panY}px) scale(${state.zoom})`;
        }

        function setZoom(newZoom) {
            const oldZoom = state.zoom;
            state.zoom = Math.max(0.5, Math.min(4, newZoom));
            // Reset pan when zooming back to 1x
            if (state.zoom <= 1) {
                state.panX = 0;
                state.panY = 0;
            } else {
                // Clamp pan so image doesn't go off-screen
                clampPan();
            }
            applyTransform();
            elements.zoomReset.textContent = `${state.zoom.toFixed(1)}x`;
            renderZones();
        }

        function clampPan() {
            const wrapper = elements.frameWrapper;
            if (!wrapper) return;
            const wrapperW = wrapper.clientWidth;
            const wrapperH = wrapper.clientHeight;
            const img = document.getElementById('frameImage');
            if (!img) return;
            const scaledW = img.clientWidth * state.zoom;
            const scaledH = img.clientHeight * state.zoom;
            // Allow panning so content stays partially visible
            const maxPanX = 0;
            const minPanX = Math.min(0, wrapperW - scaledW);
            const maxPanY = 0;
            const minPanY = Math.min(0, wrapperH - scaledH);
            state.panX = Math.max(minPanX, Math.min(maxPanX, state.panX));
            state.panY = Math.max(minPanY, Math.min(maxPanY, state.panY));
        }

        function checkReadyToSave() {
            // Need START zone. For END: either END zone (zone mode) or duration setting (duration mode)
            const endReady = state.endMode === 'duration' || state.endZone;
            const ready = state.startZone && endReady;
            elements.saveConfig.disabled = !ready;
        }

        function updateSaveButtonText() {
            const sourceType = elements.sourceType.value;
            const buttonText = sourceType === 'video' ? 'Process Video' : 'Start Live Session';
            elements.saveConfig.textContent = buttonText;
        }

        function showCalibrationBadge() {
            if (!state.activeCalibrationId) return;
            const disciplineNames = {
                'sl_youth': 'Slalom Youth', 'sl_adult': 'Slalom',
                'gs_panel': 'GS Panel', 'sg_panel': 'Super-G Panel'
            };
            const discName = disciplineNames[state.activeCalibrationDiscipline] || state.activeCalibrationDiscipline;
            const camId = state.activeCalibrationCameraId || 'unknown';
            elements.calibrationBadge.style.display = 'block';
            elements.calibrationBadgeInfo.textContent = `${camId} | ${discName} | ${state.activeCalibrationId}`;
        }

        function dismissCalibrationBadge() {
            state.activeCalibrationId = null;
            state.activeCalibrationDiscipline = null;
            state.activeCalibrationCameraId = null;
            elements.calibrationBadge.style.display = 'none';
        }

        async function saveConfig() {
            console.log('saveConfig called');
            console.log('state:', state);

            // Validate based on end mode
            if (!state.startZone) {
                showStatus('Please draw START zone', 'error');
                return;
            }
            if (state.endMode === 'zone' && !state.endZone) {
                showStatus('Please draw END zone (or switch to duration mode)', 'error');
                return;
            }

            const isVideo = elements.sourceType.value === 'video';
            const buttonText = isVideo ? 'Process Video' : 'Start Live Session';
            elements.saveConfig.innerHTML = `<span class="spinner"></span>${isVideo ? 'Processing...' : 'Saving...'}`;
            elements.saveConfig.disabled = true;

            try {
                // For video files, use the Vola camera (if set) since that determines which camera's videos we're processing
                let cameraId = state.cameraId;
                if (isVideo && state.volaCamera) {
                    cameraId = state.volaCamera;  // Use Vola camera selection for video processing
                } else if (!cameraId && isVideo) {
                    cameraId = elements.videoDropdown.value || 'video_file';
                }
                console.log('cameraId:', cameraId);

                // Determine discipline: use calibration discipline if active, else freeski
                const discipline = state.activeCalibrationId
                    ? state.activeCalibrationDiscipline
                    : (state.montageSubMode === 'gates'
                        ? document.getElementById('gatesDiscipline').value
                        : 'freeski');

                const config = {
                    camera_id: cameraId,
                    calibration_frame_id: state.frameId,
                    calibration_id: state.activeCalibrationId || null,
                    session_type: elements.sessionType.value,
                    group: elements.group.value,
                    discipline: discipline,
                    start_zone: state.startZone,
                    end_zone: state.endMode === 'zone' ? state.endZone : null,  // Only include if zone mode
                    crop_zone: state.cropZone || null,  // Optional - if set, overrides trigger zone crop calculation
                    session_end_time: new Date(elements.endTime.value).toISOString(),
                    detection_threshold: parseInt(elements.threshold.value),
                    min_pixel_change_pct: parseFloat(elements.minPixels.value),
                    start_offset_sec: state.startOffsetSec,  // Fixed delay in seconds after trigger
                    min_brightness: parseInt(elements.minBrightness.value),
                    pre_buffer_seconds: parseInt(elements.preBuffer.value),
                    post_buffer_seconds: parseInt(elements.postBuffer.value),
                    // Duration mode settings
                    run_duration_seconds: state.endMode === 'duration' ? state.runDurationSeconds : null,
                    // Montage settings
                    montage_fps_list: state.montageFpsList,
                };

                // For video files, include the video path and Vola racer data for processing
                if (isVideo) {
                    config.video_path = elements.videoDropdown.value;

                    // Include Vola racer data and videos if loaded
                    if (state.volaRacers && state.volaRacers.length > 0) {
                        config.vola_racers = state.volaRacers;
                        config.vola_videos = state.volaVideos;  // Videos to process
                        config.vola_race = state.volaRace;
                        config.vola_camera = state.volaCamera;
                        config.vola_view = state.volaView;  // View number 1-5 for filename
                        config.num_athletes = state.numAthletes;
                        // Use date from Vola data or parse from filename
                        config.race_date = state.raceDate || new Date().toISOString().split('T')[0];
                    }
                }

                console.log('config to save:', config);

                const res = await fetch('/api/config/save', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(config)
                });
                console.log('response status:', res.status);

                const data = await res.json();
                console.log('response data:', data);

                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                if (isVideo) {
                    // For video files, launch processing asynchronously
                    // If Vola data loaded, process all videos from config; otherwise use selected video
                    const hasVolaVideos = state.volaVideos && state.volaVideos.length > 0;
                    const videoPath = elements.videoDropdown.value;

                    if (!hasVolaVideos && !videoPath) {
                        showStatus('No video selected', 'error');
                        return;
                    }

                    const numVideos = hasVolaVideos ? state.volaVideos.length : 1;
                    showStatus(`Config saved: ${data.session_id}. Processing ${numVideos} video(s)...`, 'info');

                    // Call the process endpoint
                    const processRes = await fetch('/api/process/video', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            config_path: data.config_path,
                            video_path: hasVolaVideos ? null : videoPath,
                            use_config_videos: hasVolaVideos
                        })
                    });

                    const processData = await processRes.json();
                    console.log('Process response:', processData);

                    if (processData.error) {
                        showStatus(`Processing error: ${processData.error}`, 'error');
                    } else {
                        // Start polling for status
                        state.currentJobId = processData.job_id;
                        elements.processingStatus.style.display = 'block';
                        elements.stopSessionSection.style.display = 'block';
                        elements.processingStatusText.textContent = 'Processing...';
                        elements.processingRuns.textContent = '0';
                        startStatusPolling();
                        showStatus(`Processing started. Job ID: ${processData.job_id}`, 'info');
                    }
                } else {
                    // For RTSP, launch live detection process
                    showStatus(`Config saved: ${data.session_id}. Starting live detection...`, 'info');

                    const processRes = await fetch('/api/process/rtsp', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config_path: data.config_path })
                    });

                    const processData = await processRes.json();
                    console.log('RTSP process response:', processData);

                    if (processData.error) {
                        showStatus(`Detection error: ${processData.error}`, 'error');
                    } else {
                        state.currentJobId = processData.job_id;
                        elements.processingStatus.style.display = 'block';
                        elements.stopSessionSection.style.display = 'block';
                        elements.processingStatusText.textContent = 'Monitoring RTSP stream...';
                        elements.processingRuns.textContent = '0';
                        startStatusPolling();
                        showStatus(`Live detection started. Job ID: ${processData.job_id}`, 'success');
                        elements.activeSession.style.display = 'block';
                        elements.activeSessionId.textContent = data.session_id;
                        elements.activeSessionEnd.textContent = new Date(config.session_end_time).toLocaleTimeString();
                    }
                }

            } catch (e) {
                console.error('saveConfig error:', e);
                showStatus('Failed: ' + e.message, 'error');
            } finally {
                elements.saveConfig.innerHTML = buttonText;
                elements.saveConfig.disabled = false;
            }
        }

        function resetProcessingUI() {
            // Hide processing status card and stop button
            elements.processingStatus.style.display = 'none';
            elements.stopSessionSection.style.display = 'none';
            elements.stopSession.innerHTML = 'Stop Session';
            elements.stopSession.disabled = false;
            stopMetricsPolling();
        }

        // ============================
        // Live Detection Metrics Chart
        // ============================
        let metricsPollingInterval = null;

        function startMetricsPolling() {
            stopMetricsPolling();
            const metricsSection = document.getElementById('metricsSection');
            if (metricsSection) metricsSection.style.display = 'block';

            metricsPollingInterval = setInterval(async () => {
                if (!state.currentJobId) {
                    stopMetricsPolling();
                    return;
                }
                try {
                    const res = await fetch(`/api/detection/metrics/${state.currentJobId}`);
                    const data = await res.json();
                    if (data.entries && data.entries.length > 0) {
                        drawMetricsChart(data.entries);
                    }
                } catch (e) {
                    // Silently ignore — metrics may not be available yet
                }
            }, 1000);
        }

        function stopMetricsPolling() {
            if (metricsPollingInterval) {
                clearInterval(metricsPollingInterval);
                metricsPollingInterval = null;
            }
            const metricsSection = document.getElementById('metricsSection');
            if (metricsSection) metricsSection.style.display = 'none';
        }

        function drawMetricsChart(entries) {
            const canvas = document.getElementById('metricsCanvas');
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            // Handle high-DPI displays
            const rect = canvas.getBoundingClientRect();
            const dpr = window.devicePixelRatio || 1;
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            const W = rect.width;
            const H = rect.height;

            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, W, H);

            // Chart area with margins
            const margin = { top: 10, right: 10, bottom: 25, left: 40 };
            const cw = W - margin.left - margin.right;
            const ch = H - margin.top - margin.bottom;

            // Find Y max (auto-scale, minimum 10%)
            let yMax = 10;
            for (const e of entries) {
                yMax = Math.max(yMax, e.start_pct, e.end_pct, e.threshold * 1.2);
            }
            yMax = Math.ceil(yMax / 5) * 5;  // Round up to nearest 5

            // Draw grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 0.5;
            ctx.font = '10px sans-serif';
            ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.textAlign = 'right';
            for (let pct = 0; pct <= yMax; pct += Math.max(1, Math.round(yMax / 5))) {
                const y = margin.top + ch - (pct / yMax) * ch;
                ctx.beginPath();
                ctx.moveTo(margin.left, y);
                ctx.lineTo(margin.left + cw, y);
                ctx.stroke();
                ctx.fillText(`${pct}%`, margin.left - 4, y + 3);
            }

            // Draw time labels on X axis
            ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(255,255,255,0.4)';
            const n = entries.length;
            const labelCount = Math.min(6, n);
            for (let i = 0; i < labelCount; i++) {
                const idx = Math.floor((i / (labelCount - 1)) * (n - 1));
                const e = entries[idx];
                const x = margin.left + (idx / (n - 1)) * cw;
                try {
                    const t = new Date(e.t);
                    const label = `${t.getHours().toString().padStart(2,'0')}:${t.getMinutes().toString().padStart(2,'0')}:${t.getSeconds().toString().padStart(2,'0')}`;
                    ctx.fillText(label, x, H - 4);
                } catch(e) {}
            }

            // Draw run-active regions (blue vertical bands)
            for (let i = 0; i < n; i++) {
                if (entries[i].run_active) {
                    const x = margin.left + (i / (n - 1)) * cw;
                    const barW = Math.max(2, cw / n);
                    ctx.fillStyle = 'rgba(59,130,246,0.15)';
                    ctx.fillRect(x - barW/2, margin.top, barW, ch);
                }
            }

            // Draw threshold line (orange dashed)
            if (entries.length > 0) {
                const threshold = entries[entries.length - 1].threshold;
                const thY = margin.top + ch - (threshold / yMax) * ch;
                ctx.strokeStyle = '#f59e0b';
                ctx.lineWidth = 1.5;
                ctx.setLineDash([6, 4]);
                ctx.beginPath();
                ctx.moveTo(margin.left, thY);
                ctx.lineTo(margin.left + cw, thY);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Draw start zone line (green)
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const x = margin.left + (i / (n - 1)) * cw;
                const y = margin.top + ch - (entries[i].start_pct / yMax) * ch;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw end zone line (red)
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 1.5;
            ctx.beginPath();
            for (let i = 0; i < n; i++) {
                const x = margin.left + (i / (n - 1)) * cw;
                const y = margin.top + ch - (entries[i].end_pct / yMax) * ch;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // Draw run trigger markers (blue vertical lines at run_count transitions)
            let prevRunCount = entries[0].run_count;
            for (let i = 1; i < n; i++) {
                if (entries[i].run_count > prevRunCount) {
                    const x = margin.left + (i / (n - 1)) * cw;
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + ch);
                    ctx.stroke();
                    // Label
                    ctx.fillStyle = '#3b82f6';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(`Run ${entries[i].run_count}`, x, margin.top - 1);
                    ctx.font = '10px sans-serif';
                }
                prevRunCount = entries[i].run_count;
            }
        }

        function startStatusPolling() {
            // Clear any existing interval
            if (state.statusPollInterval) {
                clearInterval(state.statusPollInterval);
            }

            // Start metrics chart polling alongside status polling
            startMetricsPolling();

            // Poll every 2 seconds
            state.statusPollInterval = setInterval(async () => {
                if (!state.currentJobId) {
                    clearInterval(state.statusPollInterval);
                    return;
                }

                try {
                    const res = await fetch(`/api/process/status/${state.currentJobId}`);
                    const data = await res.json();

                    if (data.error) {
                        console.error('Status poll error:', data.error);
                        return;
                    }

                    const newRuns = data.runs_detected || 0;
                    elements.processingRuns.textContent = newRuns;
                    // Refresh gallery when new runs detected
                    if (newRuns > 0 && state.mode === 'gallery') { loadGalleryMontages(); }

                    if (data.status === 'completed') {
                        clearInterval(state.statusPollInterval);
                        state.statusPollInterval = null;
                        state.currentJobId = null;
                        resetProcessingUI();
                        showStatus(`Processing complete! ${data.runs_detected} runs detected. Output: ${data.output_dir}`, 'success');
                    } else if (data.status === 'stopped') {
                        clearInterval(state.statusPollInterval);
                        state.statusPollInterval = null;
                        state.currentJobId = null;
                        resetProcessingUI();
                        showStatus(`Processing stopped. ${data.runs_detected} runs detected before stopping.`, 'info');
                    } else if (data.status === 'failed') {
                        clearInterval(state.statusPollInterval);
                        state.statusPollInterval = null;
                        state.currentJobId = null;
                        resetProcessingUI();
                        showStatus(`Processing failed: ${data.error}`, 'error');
                    } else {
                        elements.processingStatusText.textContent = 'Processing...';
                    }
                } catch (e) {
                    console.error('Status poll failed:', e);
                }
            }, 2000);
        }

        // ============================
        // Montage Gallery (Gallery Tab)
        // ============================
        let galleryPollingInterval = null;
        let galleryMontages = [];  // All montages from API
        let galleryFpsFilter = null;  // Current FPS filter (null until montages load, then defaults to slowest)

        async function loadGalleryMontages() {
            try {
                const res = await fetch('/api/montages/latest');
                const data = await res.json();
                galleryMontages = data.montages || [];
                updateGalleryFpsButtons();
                renderGallery();
            } catch (e) {
                console.error('Failed to load gallery montages:', e);
            }
        }

        function updateGalleryFpsButtons() {
            const container = document.getElementById('galleryFpsButtons');
            if (!container) return;

            // Collect unique FPS values
            const fpsValues = new Set();
            galleryMontages.forEach(m => {
                if (m.fps !== null && m.fps !== undefined) fpsValues.add(m.fps);
            });

            const sorted = [...fpsValues].sort((a, b) => a - b);

            // Default to slowest FPS if no filter set or previous filter no longer available
            if (sorted.length > 0 && (galleryFpsFilter === null || !fpsValues.has(parseFloat(galleryFpsFilter)))) {
                galleryFpsFilter = String(sorted[0]);
            }

            // Build buttons: each FPS value (slowest first)
            let html = '';
            sorted.forEach(fps => {
                const label = fps % 1 === 0 ? fps.toFixed(0) : fps.toFixed(1);
                const active = galleryFpsFilter === String(fps) ? 'active' : '';
                html += `<button type="button" class="fps-btn ${active}" data-fps="${fps}">${label}</button>`;
            });
            container.innerHTML = html;

            // Click handlers
            container.querySelectorAll('.fps-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    galleryFpsFilter = btn.dataset.fps;
                    container.querySelectorAll('.fps-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    renderGallery();
                });
            });
        }

        function renderGallery() {
            const grid = document.getElementById('galleryGrid');
            const countEl = document.getElementById('galleryMontageCount');
            if (!grid) return;

            // Filter by FPS
            let filtered = galleryMontages;
            if (galleryFpsFilter !== null) {
                const targetFps = parseFloat(galleryFpsFilter);
                filtered = galleryMontages.filter(m => m.fps === targetFps);
            }

            if (filtered.length === 0) {
                grid.innerHTML = '<div style="color: var(--text-muted); font-size: 14px; text-align: center; padding: 20px;">No montages found</div>';
                if (countEl) countEl.textContent = '';
                return;
            }

            if (countEl) countEl.textContent = `${filtered.length} of ${galleryMontages.length} images`;

            grid.innerHTML = filtered.map(m => {
                const label = m.filename.replace('.jpg', '').replace(/_/g, ' ');
                const fpsTag = m.fps !== null ? `<span class="montage-fps-tag">${m.fps % 1 === 0 ? m.fps.toFixed(0) : m.fps.toFixed(1)} fps</span>` : '';
                return `<div class="montage-thumb" onclick="showMontageFullscreen('/api/montages/image/${m.path}')">
                    <img src="/api/montages/image/${m.path}" loading="lazy">
                    ${fpsTag}
                    <div class="montage-label">${label}</div>
                </div>`;
            }).join('');
        }

        function showMontageFullscreen(src) {
            const overlay = document.getElementById('montageOverlay');
            const img = document.getElementById('montageOverlayImg');
            img.src = src;
            overlay.classList.add('visible');
        }

        // Close fullscreen on click
        document.getElementById('montageOverlay').addEventListener('click', () => {
            document.getElementById('montageOverlay').classList.remove('visible');
        });

        function startGalleryPolling() {
            if (galleryPollingInterval) return;
            galleryPollingInterval = setInterval(loadGalleryMontages, 5000);
        }

        function stopGalleryPolling() {
            if (galleryPollingInterval) {
                clearInterval(galleryPollingInterval);
                galleryPollingInterval = null;
            }
        }

        function showStatus(message, type) {
            elements.status.textContent = message;
            elements.status.className = `status ${type}`;
            elements.status.style.display = 'block';
            setTimeout(() => {
                elements.status.style.display = 'none';
            }, 5000);
        }

        // ============================================
        // VIDEO STITCH MODE FUNCTIONS
        // ============================================

        function switchMode(mode) {
            state.mode = mode;
            // Hide all mode divs
            elements.montageMode.style.display = 'none';
            elements.galleryMode.style.display = 'none';
            elements.stitchMode.style.display = 'none';
            // Reset all mode buttons
            [elements.modeCalibration, elements.modeGallery, elements.modeStitch].forEach(btn => {
                btn.classList.remove('btn-primary');
                btn.classList.add('btn-outline');
            });

            if (mode === 'montage') {
                elements.montageMode.style.display = 'block';
                elements.modeCalibration.classList.add('btn-primary');
                elements.modeCalibration.classList.remove('btn-outline');
                // Initialize the active sub-mode
                switchSubMode(state.montageSubMode || 'freeski');
            } else if (mode === 'gallery') {
                elements.galleryMode.style.display = 'block';
                elements.modeGallery.classList.add('btn-primary');
                elements.modeGallery.classList.remove('btn-outline');
                // Load gallery
                loadGalleryMontages();
                startGalleryPolling();
            } else if (mode === 'stitch') {
                elements.stitchMode.style.display = 'block';
                elements.modeStitch.classList.add('btn-primary');
                elements.modeStitch.classList.remove('btn-outline');
                // Load stitch-specific data
                loadStitchVolaFiles();
                loadStitchConfigs();
                loadLogos();
            }
        }

        function switchSubMode(subMode) {
            state.montageSubMode = subMode;
            // Toggle sub-mode buttons
            elements.subModeGates.classList.remove('btn-primary', 'btn-outline');
            elements.subModeFreeSki.classList.remove('btn-primary', 'btn-outline');
            // Toggle sub-mode content
            if (subMode === 'gates') {
                elements.subModeGates.classList.add('btn-primary');
                elements.subModeFreeSki.classList.add('btn-outline');
                elements.gatesMode.style.display = 'block';
                elements.freeSkiMode.style.display = 'none';
                initGatesMode();
            } else {
                elements.subModeFreeSki.classList.add('btn-primary');
                elements.subModeGates.classList.add('btn-outline');
                elements.gatesMode.style.display = 'none';
                elements.freeSkiMode.style.display = 'block';
            }
        }

        async function loadStitchVolaFiles() {
            try {
                const res = await fetch('/api/vola/files');
                const files = await res.json();
                elements.stitchVolaFile.innerHTML = files.length === 0
                    ? '<option value="">No Vola files found</option>'
                    : files.map(f => `<option value="${f.path}">${f.name}</option>`).join('');

                const resStartlist = await fetch('/api/vola/startlist-files');
                const startlistFiles = await resStartlist.json();
                elements.stitchStartlistFile.innerHTML = '<option value="">-- None (use bib numbers) --</option>' +
                    startlistFiles.map(f => `<option value="${f.path}">${f.name}</option>`).join('');

                const resResults = await fetch('/api/vola/results-files');
                const resultsFiles = await resResults.json();
                elements.stitchResultsFile.innerHTML = '<option value="">-- None --</option>' +
                    resultsFiles.map(f => `<option value="${f.path}">${f.name}</option>`).join('');
            } catch (e) {
                console.error('Error loading Vola files:', e);
            }
        }

        async function loadStitchConfigs() {
            try {
                const res = await fetch('/api/stitch/configs');
                const configs = await res.json();
                elements.stitchConfigSelect.innerHTML = '<option value="">-- New Configuration --</option>' +
                    configs.map(c => `<option value="${c.filename}">${c.name}</option>`).join('');
            } catch (e) {
                console.error('Error loading stitch configs:', e);
            }
        }

        async function loadLogos() {
            try {
                const res = await fetch('/api/stitch/logos');
                const data = await res.json();
                const logos = data.logos || [];
                const defaultOrder = data.default_order || [];
                const excludedByDefault = data.excluded_by_default || [];

                state.availableLogos = logos;

                // Use default order from API, filter to only existing logos
                state.selectedLogos = defaultOrder.filter(name => logos.some(l => l.filename === name));

                // Add any logos not in default order (before the last one), except excluded ones
                logos.forEach(l => {
                    if (!state.selectedLogos.includes(l.filename) && !excludedByDefault.includes(l.filename)) {
                        const insertAt = state.selectedLogos.length > 0 ? state.selectedLogos.length - 1 : 0;
                        state.selectedLogos.splice(insertAt, 0, l.filename);
                    }
                });

                renderLogoList();
            } catch (e) {
                console.error('Error loading logos:', e);
            }
        }

        function renderLogoList() {
            const container = elements.logoList;
            container.innerHTML = state.selectedLogos.map((filename, index) => {
                const logo = state.availableLogos.find(l => l.filename === filename);
                return `
                    <div class="logo-item" draggable="true" data-filename="${filename}" data-index="${index}"
                         style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: white; border: 1px solid #d1d5db; border-radius: 4px; cursor: grab;">
                        <input type="checkbox" checked onchange="toggleLogo('${filename}')" style="width: 16px; height: 16px;">
                        <img src="/api/stitch/logo/${filename}" alt="${filename}" style="height: 24px; max-width: 60px; object-fit: contain;">
                        <span style="flex: 1; font-size: 12px; color: #64748b; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${filename.replace(/_/g, ' ').replace('.png', '')}</span>
                        <span style="color: #94a3b8; font-size: 14px;">☰</span>
                    </div>
                `;
            }).join('');

            // Also show unselected logos
            const unselected = state.availableLogos.filter(l => !state.selectedLogos.includes(l.filename));
            if (unselected.length > 0) {
                container.innerHTML += unselected.map(logo => `
                    <div class="logo-item" data-filename="${logo.filename}"
                         style="display: flex; align-items: center; gap: 8px; padding: 6px 8px; background: #f1f5f9; border: 1px solid #e2e8f0; border-radius: 4px; opacity: 0.6;">
                        <input type="checkbox" onchange="toggleLogo('${logo.filename}')" style="width: 16px; height: 16px;">
                        <img src="/api/stitch/logo/${logo.filename}" alt="${logo.filename}" style="height: 24px; max-width: 60px; object-fit: contain;">
                        <span style="flex: 1; font-size: 12px; color: #94a3b8; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${logo.filename.replace(/_/g, ' ').replace('.png', '')}</span>
                    </div>
                `).join('');
            }

            // Add drag and drop handlers
            setupLogoDragDrop();
        }

        function toggleLogo(filename) {
            const index = state.selectedLogos.indexOf(filename);
            if (index >= 0) {
                state.selectedLogos.splice(index, 1);
            } else {
                // Add before the last logo (Skiframes-com)
                const lastIdx = state.selectedLogos.length > 0 ? state.selectedLogos.length - 1 : 0;
                state.selectedLogos.splice(lastIdx, 0, filename);
            }
            renderLogoList();
        }

        function setupLogoDragDrop() {
            const items = document.querySelectorAll('.logo-item[draggable="true"]');
            let draggedItem = null;

            items.forEach(item => {
                item.addEventListener('dragstart', (e) => {
                    draggedItem = item;
                    item.style.opacity = '0.5';
                });

                item.addEventListener('dragend', () => {
                    draggedItem.style.opacity = '1';
                    draggedItem = null;
                });

                item.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if (draggedItem && draggedItem !== item) {
                        const rect = item.getBoundingClientRect();
                        const midY = rect.top + rect.height / 2;
                        if (e.clientY < midY) {
                            item.style.borderTop = '2px solid #3b82f6';
                            item.style.borderBottom = '';
                        } else {
                            item.style.borderBottom = '2px solid #3b82f6';
                            item.style.borderTop = '';
                        }
                    }
                });

                item.addEventListener('dragleave', () => {
                    item.style.borderTop = '';
                    item.style.borderBottom = '';
                });

                item.addEventListener('drop', (e) => {
                    e.preventDefault();
                    item.style.borderTop = '';
                    item.style.borderBottom = '';

                    if (draggedItem && draggedItem !== item) {
                        const fromFilename = draggedItem.dataset.filename;
                        const toFilename = item.dataset.filename;
                        const fromIndex = state.selectedLogos.indexOf(fromFilename);
                        let toIndex = state.selectedLogos.indexOf(toFilename);

                        if (fromIndex >= 0 && toIndex >= 0) {
                            // Remove from old position
                            state.selectedLogos.splice(fromIndex, 1);
                            // Adjust toIndex if needed
                            if (fromIndex < toIndex) toIndex--;

                            // Determine if dropping before or after
                            const rect = item.getBoundingClientRect();
                            const midY = rect.top + rect.height / 2;
                            if (e.clientY >= midY) toIndex++;

                            // Insert at new position
                            state.selectedLogos.splice(toIndex, 0, fromFilename);
                            renderLogoList();
                        }
                    }
                });
            });
        }

        async function loadStitchRacers() {
            const volaFile = elements.stitchVolaFile.value;
            const race = elements.stitchRace.value;
            const startlistFile = elements.stitchStartlistFile.value;
            const resultsFile = elements.stitchResultsFile.value;

            if (!volaFile) {
                showStatus('Please select a Vola file', 'error');
                return;
            }

            try {
                showStatus('Loading racers...', 'info');
                const res = await fetch('/api/stitch/parse-racers', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        vola_file: volaFile,
                        race: race,
                        startlist_file: startlistFile,
                        results_file: resultsFile
                    })
                });

                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                state.stitchRacers = data.racers;
                state.stitchVideoPaths = data.video_paths || {};
                elements.stitchRacerCount.textContent = data.total_racers;

                // Populate table
                elements.stitchRacersTable.innerHTML = data.racers.map(r => `
                    <tr>
                        <td style="padding: 4px;">${r.bib}</td>
                        <td style="padding: 4px;">${r.name}</td>
                        <td style="padding: 4px;">${r.team}</td>
                        <td style="padding: 4px;">${r.start_time_str}</td>
                        <td style="padding: 4px;">${r.run_duration ? r.run_duration.toFixed(1) + 's' : '-'}</td>
                    </tr>
                `).join('');

                elements.stitchRacersInfo.style.display = 'block';
                elements.stitchCutsCard.style.display = 'block';
                elements.stitchVideosCard.style.display = 'block';
                elements.stitchProcessCard.style.display = 'block';

                // Display auto-detected video paths (now arrays)
                const formatVideos = (paths) => {
                    if (!paths || paths.length === 0) return 'Not found';
                    if (paths.length === 1) return paths[0].split('/').pop();
                    return `${paths.length} files`;
                };
                elements.stitchVideoR1Display.textContent = formatVideos(state.stitchVideoPaths.R1);
                elements.stitchVideoAxisDisplay.textContent = formatVideos(state.stitchVideoPaths.Axis);
                elements.stitchVideoR2Display.textContent = formatVideos(state.stitchVideoPaths.R2);
                elements.stitchVideoR3Display.textContent = formatVideos(state.stitchVideoPaths.R3);

                // Show warning if any videos missing
                const missingCameras = ['R1', 'Axis', 'R2', 'R3'].filter(c => !state.stitchVideoPaths[c] || state.stitchVideoPaths[c].length === 0);
                if (missingCameras.length > 0) {
                    elements.stitchVideosMissing.textContent = `Warning: No videos found for: ${missingCameras.join(', ')}`;
                    elements.stitchVideosMissing.style.display = 'block';
                } else {
                    elements.stitchVideosMissing.style.display = 'none';
                }

                // Auto-select config if matching race name exists
                const raceNameClean = race.toLowerCase().replace(/\s+/g, '_');
                const matchingOption = Array.from(elements.stitchConfigSelect.options)
                    .find(opt => opt.value.includes(raceNameClean));
                if (matchingOption) {
                    elements.stitchConfigSelect.value = matchingOption.value;
                    loadStitchConfigValues(matchingOption.value);
                }

                // Set config name default
                elements.stitchConfigName.value = race;

                showStatus(`Loaded ${data.total_racers} racers, ${4 - missingCameras.length}/4 videos found`, 'success');
            } catch (e) {
                showStatus('Error loading racers: ' + e.message, 'error');
            }
        }

        async function loadStitchConfigValues(filename) {
            if (!filename) return;

            try {
                const name = filename.replace('.json', '');
                const res = await fetch(`/api/stitch/config/${name}`);
                const config = await res.json();

                if (config.error) return;

                // Populate cut inputs
                for (const cut of config.cuts) {
                    const cam = cut.camera;
                    const startInput = document.getElementById(`stitchCut${cam}Start`);
                    const endInput = document.getElementById(`stitchCut${cam}End`);
                    if (startInput) startInput.value = cut.start_pct * 100;
                    if (endInput) endInput.value = cut.end_pct * 100;
                }

                elements.stitchConfigName.value = config.name || '';
            } catch (e) {
                console.error('Error loading config:', e);
            }
        }

        async function saveStitchConfig() {
            const name = elements.stitchConfigName.value.trim();
            if (!name) {
                showStatus('Please enter a config name', 'error');
                return;
            }

            const cuts = [
                { camera: 'R1', start_pct: parseFloat(elements.stitchCutR1Start.value) / 100, end_pct: parseFloat(elements.stitchCutR1End.value) / 100 },
                { camera: 'Axis', start_pct: parseFloat(elements.stitchCutAxisStart.value) / 100, end_pct: parseFloat(elements.stitchCutAxisEnd.value) / 100 },
                { camera: 'R2', start_pct: parseFloat(elements.stitchCutR2Start.value) / 100, end_pct: parseFloat(elements.stitchCutR2End.value) / 100 },
                { camera: 'R3', start_pct: parseFloat(elements.stitchCutR3Start.value) / 100, end_pct: parseFloat(elements.stitchCutR3End.value) / 100 },
            ];

            try {
                const res = await fetch('/api/stitch/config', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name, cuts })
                });

                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                showStatus('Config saved', 'success');
                loadStitchConfigs();
            } catch (e) {
                showStatus('Error saving config: ' + e.message, 'error');
            }
        }

        function getStitchCuts() {
            return [
                { camera: 'R1', start_pct: parseFloat(elements.stitchCutR1Start.value) / 100, end_pct: parseFloat(elements.stitchCutR1End.value) / 100 },
                { camera: 'Axis', start_pct: parseFloat(elements.stitchCutAxisStart.value) / 100, end_pct: parseFloat(elements.stitchCutAxisEnd.value) / 100 },
                { camera: 'R2', start_pct: parseFloat(elements.stitchCutR2Start.value) / 100, end_pct: parseFloat(elements.stitchCutR2End.value) / 100 },
                { camera: 'R3', start_pct: parseFloat(elements.stitchCutR3Start.value) / 100, end_pct: parseFloat(elements.stitchCutR3End.value) / 100 },
            ];
        }

        async function startStitchProcess() {
            // Validate
            if (state.stitchRacers.length === 0) {
                showStatus('No racers loaded', 'error');
                return;
            }

            // Use auto-detected video paths (now arrays)
            const videoPaths = state.stitchVideoPaths;

            // Check all videos detected (arrays must have at least one element)
            const missingCameras = ['R1', 'Axis', 'R2', 'R3'].filter(c => !videoPaths[c] || videoPaths[c].length === 0);
            if (missingCameras.length > 0) {
                showStatus(`Missing videos for: ${missingCameras.join(', ')}. Check recordings directory.`, 'error');
                return;
            }

            const cuts = getStitchCuts();
            const raceName = elements.stitchRace.value.toLowerCase().replace(/\s+/g, '_');
            const generateComparison = elements.stitchGenerateComparison.checked;
            const testCount = parseInt(elements.stitchTestCount.value) || 0;

            // Build race_info from form fields
            const raceInfo = {
                event: elements.raceInfoEvent.value.trim(),
                discipline: elements.raceInfoDiscipline.value.trim(),
                age_group: elements.raceInfoAgeGroup.value.trim(),
                run: elements.raceInfoRun.value.trim(),
                date: elements.raceInfoDate.value.trim(),
                type: elements.raceInfoType.value.trim(),
                course: elements.raceInfoCourse.value.trim(),
                location: elements.raceInfoLocation.value.trim(),
                vertical_drop: elements.raceInfoVertical.value.trim(),
                length: elements.raceInfoLength.value.trim(),
                gates: elements.raceInfoGates.value.trim(),
                snow: elements.raceInfoSnow.value.trim()
            };

            // Limit racers if test count is set
            let racersToProcess = state.stitchRacers;
            if (testCount > 0 && testCount < state.stitchRacers.length) {
                racersToProcess = state.stitchRacers.slice(0, testCount);
                console.log(`Test mode: processing ${testCount} of ${state.stitchRacers.length} racers`);
            }

            try {
                elements.stitchStartProcess.disabled = true;
                elements.stitchStopProcess.style.display = 'block';
                elements.stitchProgress.style.display = 'block';
                elements.stitchResults.style.display = 'none';
                elements.stitchError.style.display = 'none';
                elements.stitchProgressBar.style.width = '0%';
                elements.stitchProgressText.textContent = 'Starting...';

                const res = await fetch('/api/stitch/process', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        racers: racersToProcess,
                        cuts: cuts,
                        video_paths: videoPaths,
                        race_name: raceName,
                        race_info: raceInfo,
                        generate_comparison: generateComparison,
                        selected_logos: state.selectedLogos
                    })
                });

                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    elements.stitchStartProcess.disabled = false;
                    return;
                }

                state.stitchJobId = data.job_id;
                pollStitchStatus();

            } catch (e) {
                showStatus('Error starting process: ' + e.message, 'error');
                elements.stitchStartProcess.disabled = false;
            }
        }

        function pollStitchStatus() {
            if (state.stitchPollInterval) {
                clearInterval(state.stitchPollInterval);
            }

            state.stitchPollInterval = setInterval(async () => {
                try {
                    const res = await fetch(`/api/stitch/job/${state.stitchJobId}`);
                    const data = await res.json();

                    if (data.error) {
                        clearInterval(state.stitchPollInterval);
                        elements.stitchError.textContent = data.error;
                        elements.stitchError.style.display = 'block';
                        elements.stitchStartProcess.disabled = false;
                        return;
                    }

                    const progress = data.progress || {};
                    const current = progress.current || 0;
                    const total = progress.total || 1;
                    const pct = Math.round((current / total) * 100);

                    elements.stitchProgressBar.style.width = pct + '%';
                    elements.stitchProgressText.textContent = `Processing racer ${current} of ${total}`;
                    elements.stitchCurrentRacer.textContent = progress.current_racer || '';

                    if (data.status === 'completed') {
                        clearInterval(state.stitchPollInterval);
                        elements.stitchProgressBar.style.width = '100%';
                        elements.stitchProgressText.textContent = 'Completed!';
                        elements.stitchResults.style.display = 'block';
                        elements.stitchOutputDir.textContent = 'Output: ' + (data.output_dir || '');
                        elements.stitchOutputCount.textContent = `Generated ${(data.outputs || []).length} videos`;
                        elements.stitchStartProcess.disabled = false;
                        elements.stitchStopProcess.style.display = 'none';
                    } else if (data.status === 'stopped') {
                        clearInterval(state.stitchPollInterval);
                        elements.stitchProgressText.textContent = 'Stopped by user';
                        elements.stitchResults.style.display = 'block';
                        elements.stitchOutputDir.textContent = 'Output: ' + (data.output_dir || '');
                        elements.stitchOutputCount.textContent = `Generated ${(data.outputs || []).length} videos before stopping`;
                        elements.stitchStartProcess.disabled = false;
                        elements.stitchStopProcess.style.display = 'none';
                    } else if (data.status === 'error') {
                        clearInterval(state.stitchPollInterval);
                        elements.stitchError.textContent = data.error || 'Unknown error';
                        elements.stitchError.style.display = 'block';
                        elements.stitchStartProcess.disabled = false;
                        elements.stitchStopProcess.style.display = 'none';
                    }

                } catch (e) {
                    console.error('Error polling status:', e);
                }
            }, 1000);
        }

        async function stopStitchProcess() {
            if (!state.stitchJobId) return;

            try {
                elements.stitchStopProcess.disabled = true;
                elements.stitchStopProcess.textContent = 'Stopping...';

                const res = await fetch(`/api/stitch/job/${state.stitchJobId}/stop`, {
                    method: 'POST'
                });

                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                } else {
                    elements.stitchProgressText.textContent = 'Stopping...';
                }
            } catch (e) {
                showStatus('Error stopping process: ' + e.message, 'error');
            } finally {
                elements.stitchStopProcess.disabled = false;
                elements.stitchStopProcess.textContent = 'Stop Processing';
            }
        }

        function updateRaceInfoFromSelection() {
            // Update age group and run fields based on selected race
            const race = elements.stitchRace.value;
            let ageGroup = 'U12';
            let runNum = 'Run 1';
            if (race.toLowerCase().includes('u14')) ageGroup = 'U14';
            if (race.toLowerCase().includes('run 2')) runNum = 'Run 2';

            elements.raceInfoAgeGroup.value = ageGroup;
            elements.raceInfoRun.value = runNum;
        }

        function setupStitchEventListeners() {
            elements.modeCalibration.addEventListener('click', () => switchMode('montage'));
            elements.modeGallery.addEventListener('click', () => switchMode('gallery'));
            elements.modeStitch.addEventListener('click', () => switchMode('stitch'));
            elements.subModeGates.addEventListener('click', () => switchSubMode('gates'));
            elements.subModeFreeSki.addEventListener('click', () => switchSubMode('freeski'));
            elements.stitchLoadRacers.addEventListener('click', loadStitchRacers);
            elements.stitchConfigSelect.addEventListener('change', () => {
                loadStitchConfigValues(elements.stitchConfigSelect.value);
            });
            elements.stitchSaveConfig.addEventListener('click', saveStitchConfig);
            elements.stitchStartProcess.addEventListener('click', startStitchProcess);
            elements.stitchStopProcess.addEventListener('click', stopStitchProcess);
            // Update race info fields when race selection changes
            elements.stitchRace.addEventListener('change', updateRaceInfoFromSelection);

            // Processing location toggle
            elements.stitchProcessLocation.addEventListener('change', function() {
                const isLocal = this.value === 'local';
                elements.localProcessingControls.style.display = isLocal ? 'block' : 'none';
                elements.serverProcessingControls.style.display = isLocal ? 'none' : 'block';
            });

            // Generate server command
            elements.stitchGenerateCommand.addEventListener('click', generateServerCommand);
            elements.copyServerCommand.addEventListener('click', function() {
                elements.serverCommandText.select();
                document.execCommand('copy');
                this.textContent = 'Copied!';
                setTimeout(() => { this.textContent = 'Copy to Clipboard'; }, 2000);
            });
        }

        // Generate command for server processing
        async function generateServerCommand() {
            const race = elements.stitchRace.value;
            const testCount = parseInt(elements.stitchTestCount.value) || 0;
            const generateComparison = elements.stitchGenerateComparison.checked;
            const preBuffer = parseFloat(elements.stitchPreBuffer.value) || 2.0;
            const postBuffer = parseFloat(elements.stitchPostBuffer.value) || 2.0;

            // Extract date from vola path (format: U12_U14_02-01-2026)
            const volaPath = elements.stitchVolaFile.value;
            let date = '20260201';
            const dateMatch = volaPath.match(/(\d{2})-(\d{2})-(\d{4})/);
            if (dateMatch) {
                date = dateMatch[3] + dateMatch[1] + dateMatch[2];
            }

            // Get all the settings from UI
            const cuts = getStitchCuts();
            const raceInfo = {
                event: elements.raceInfoEvent.value.trim(),
                discipline: elements.raceInfoDiscipline.value.trim(),
                age_group: elements.raceInfoAgeGroup.value.trim(),
                run: elements.raceInfoRun.value.trim(),
                date: elements.raceInfoDate.value.trim(),
                type: elements.raceInfoType.value.trim(),
            };

            try {
                const res = await fetch('/api/stitch/server-command', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        race: race,
                        date: date,
                        workers: 8,
                        test_count: testCount,
                        generate_comparison: generateComparison,
                        pre_buffer: preBuffer,
                        post_buffer: postBuffer,
                        vola_file: volaPath,
                        results_file: elements.stitchResultsFile ? elements.stitchResultsFile.value : null,
                        cuts: cuts,
                        race_info: raceInfo,
                        selected_logos: state.selectedLogos
                    })
                });

                const data = await res.json();
                elements.serverCommandText.value = data.ssh_command;
                elements.serverCommandOutput.style.display = 'block';
            } catch (e) {
                showStatus('Error generating command: ' + e.message, 'error');
            }
        }

        // ============================================
        // GATES CALIBRATION MODE FUNCTIONS
        // ============================================

        const gatesEl = {
            sourceRtsp: document.getElementById('gatesSourceRtsp'),
            sourceVideo: document.getElementById('gatesSourceVideo'),
            rtspSection: document.getElementById('gatesRtspSection'),
            videoSection: document.getElementById('gatesVideoSection'),
            cameraSelect: document.getElementById('gatesCameraSelect'),
            videoDropdown: document.getElementById('gatesVideoDropdown'),
            seekPosition: document.getElementById('gatesSeekPosition'),
            seekTime: document.getElementById('gatesSeekTime'),
            videoDuration: document.getElementById('gatesVideoDuration'),
            grabFrame: document.getElementById('gatesGrabFrame'),
            uploadVideo: document.getElementById('gatesUploadVideo'),
            videoUploadInput: document.getElementById('gatesVideoUploadInput'),
            uploadProgress: document.getElementById('gatesUploadProgress'),
            uploadFill: document.getElementById('gatesUploadFill'),
            uploadStatus: document.getElementById('gatesUploadStatus'),
            detectionCard: document.getElementById('gatesDetectionCard'),
            discipline: document.getElementById('gatesDiscipline'),
            advancedToggle: document.getElementById('gatesAdvancedToggle'),
            advancedArrow: document.getElementById('gatesAdvancedArrow'),
            advancedSettings: document.getElementById('gatesAdvancedSettings'),
            minHeight: document.getElementById('gatesMinHeight'),
            minHeightVal: document.getElementById('gatesMinHeightVal'),
            maxHeight: document.getElementById('gatesMaxHeight'),
            maxHeightVal: document.getElementById('gatesMaxHeightVal'),
            satThresh: document.getElementById('gatesSatThresh'),
            satThreshVal: document.getElementById('gatesSatThreshVal'),
            valThresh: document.getElementById('gatesValThresh'),
            valThreshVal: document.getElementById('gatesValThreshVal'),
            detectBtn: document.getElementById('gatesDetectBtn'),
            reviewCard: document.getElementById('gatesReviewCard'),
            frameContainer: document.getElementById('gatesFrameContainer'),
            frameImage: document.getElementById('gatesFrameImage'),
            gatesCount: document.getElementById('gatesCount'),
            addBlueBtn: document.getElementById('gatesAddBlueBtn'),
            addRedBtn: document.getElementById('gatesAddRedBtn'),
            addInstructions: document.getElementById('gatesAddInstructions'),
            cancelAdd: document.getElementById('gatesCancelAdd'),
            minWarning: document.getElementById('gatesMinWarning'),
            computeBtn: document.getElementById('gatesComputeBtn'),
            verifyCard: document.getElementById('gatesVerifyCard'),
            verifyImage: document.getElementById('gatesVerifyImage'),
            reprojError: document.getElementById('gatesReprojError'),
            reprojQuality: document.getElementById('gatesReprojQuality'),
            readjustBtn: document.getElementById('gatesReadjustBtn'),
            acceptBtn: document.getElementById('gatesAcceptBtn'),
            statusList: document.getElementById('gatesStatusList'),
            // GPS elements
            gpsEnable: document.getElementById('gpsEnable'),
            gpsBody: document.getElementById('gpsBody'),
            gpsStatusDot: document.getElementById('gpsStatusDot'),
            gpsLiveAccuracy: document.getElementById('gpsLiveAccuracy'),
            gpsCaptureCamera: document.getElementById('gpsCaptureCamera'),
            gpsLoadSaved: document.getElementById('gpsLoadSaved'),
            gpsCameraInfo: document.getElementById('gpsCameraInfo'),
            gpsCameraLat: document.getElementById('gpsCameraLat'),
            gpsCameraLon: document.getElementById('gpsCameraLon'),
            gpsCameraAcc: document.getElementById('gpsCameraAcc'),
            gpsWalkGatesBtn: document.getElementById('gpsWalkGatesBtn'),
            gpsGateSummary: document.getElementById('gpsGateSummary'),
            gpsWalkOverlay: document.getElementById('gpsWalkOverlay'),
            gpsWalkGateLabel: document.getElementById('gpsWalkGateLabel'),
            gpsWalkAccuracy: document.getElementById('gpsWalkAccuracy'),
            gpsWalkQualityFill: document.getElementById('gpsWalkQualityFill'),
            gpsWalkCaptureBtn: document.getElementById('gpsWalkCaptureBtn'),
            gpsWalkSkipBtn: document.getElementById('gpsWalkSkipBtn'),
            gpsWalkDots: document.getElementById('gpsWalkDots'),
            gpsWalkCancelBtn: document.getElementById('gpsWalkCancelBtn'),
        };

        let gatesVideoDuration = 0;

        async function initGatesMode() {
            // Populate camera dropdown
            try {
                const res = await fetch('/api/cameras');
                const cameras = await res.json();
                gatesEl.cameraSelect.innerHTML = cameras.map(c =>
                    `<option value="${c.id}">${c.name}</option>`
                ).join('');
            } catch (e) { console.error('Failed to load cameras:', e); }

            // Load calibration status
            loadCalibrationStatus();
        }

        function gatesSwitchSource(type) {
            state.gatesSourceType = type;
            if (type === 'rtsp') {
                gatesEl.sourceRtsp.classList.add('btn-primary');
                gatesEl.sourceRtsp.classList.remove('btn-outline');
                gatesEl.sourceVideo.classList.remove('btn-primary');
                gatesEl.sourceVideo.classList.add('btn-outline');
                gatesEl.rtspSection.style.display = 'block';
                gatesEl.videoSection.style.display = 'none';
            } else {
                gatesEl.sourceVideo.classList.add('btn-primary');
                gatesEl.sourceVideo.classList.remove('btn-outline');
                gatesEl.sourceRtsp.classList.remove('btn-primary');
                gatesEl.sourceRtsp.classList.add('btn-outline');
                gatesEl.rtspSection.style.display = 'none';
                gatesEl.videoSection.style.display = 'block';
                loadGatesVideoList();
            }
        }

        async function loadGatesVideoList() {
            try {
                const res = await fetch('/api/videos');
                const videos = await res.json();
                gatesEl.videoDropdown.innerHTML = '<option value="">Select a video...</option>' +
                    videos.map(v => `<option value="${v.path}">${v.name}</option>`).join('');
                // If we have an uploaded video, add it to the list
                if (state.gatesUploadedVideoPath) {
                    const name = state.gatesUploadedVideoPath.split('/').pop();
                    gatesEl.videoDropdown.innerHTML += `<option value="${state.gatesUploadedVideoPath}" selected>${name} (uploaded)</option>`;
                }
            } catch (e) { console.error('Failed to load videos:', e); }
        }

        async function gatesLoadVideoInfo() {
            const videoPath = gatesEl.videoDropdown.value;
            if (!videoPath) return;
            try {
                const res = await fetch('/api/video/info', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ video_path: videoPath }),
                });
                const info = await res.json();
                if (info.duration) {
                    gatesVideoDuration = info.duration;
                    gatesEl.videoDuration.textContent = formatTime(info.duration);
                    gatesEl.seekPosition.max = info.duration;
                }
            } catch (e) { console.error('Failed to get video info:', e); }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        async function gatesGrabFrame() {
            gatesEl.grabFrame.disabled = true;
            gatesEl.grabFrame.textContent = 'Grabbing...';

            const body = { source_type: state.gatesSourceType };
            if (state.gatesSourceType === 'rtsp') {
                body.camera_id = gatesEl.cameraSelect.value;
            } else {
                body.video_path = gatesEl.videoDropdown.value;
                body.seek_seconds = parseFloat(gatesEl.seekPosition.value) || 0;
            }

            try {
                const res = await fetch('/api/frame/grab', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(body),
                });
                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }
                state.gatesFrameId = data.frame_id;
                state.gatesFrameWidth = data.width;
                state.gatesFrameHeight = data.height;

                // Show the grabbed frame immediately
                gatesEl.reviewCard.style.display = 'block';
                gatesEl.frameImage.src = `/api/frame/${data.frame_id}?t=${Date.now()}`;
                // Clear old pins
                document.querySelectorAll('.gate-pin, .gate-label, .gate-line, .gate-dismiss').forEach(el => el.remove());

                // Show detection card
                gatesEl.detectionCard.style.display = 'block';

                // Reset verify
                gatesEl.verifyCard.style.display = 'none';
                state.gates = [];
                updateGatesCount();

                showStatus('Frame grabbed. Select discipline and detect gates.', 'success');
            } catch (e) {
                showStatus('Error grabbing frame: ' + e.message, 'error');
            } finally {
                gatesEl.grabFrame.disabled = false;
                gatesEl.grabFrame.textContent = 'Grab Frame';
            }
        }

        async function gatesUploadVideo() {
            const file = gatesEl.videoUploadInput.files[0];
            if (!file) return;

            const formData = new FormData();
            formData.append('video', file);

            gatesEl.uploadProgress.style.display = 'block';
            gatesEl.uploadFill.style.width = '0%';
            gatesEl.uploadStatus.textContent = 'Uploading...';

            const xhr = new XMLHttpRequest();
            xhr.upload.addEventListener('progress', (e) => {
                if (e.lengthComputable) {
                    const pct = (e.loaded / e.total * 100).toFixed(0);
                    gatesEl.uploadFill.style.width = pct + '%';
                    gatesEl.uploadStatus.textContent = `Uploading... ${pct}%`;
                }
            });
            xhr.addEventListener('load', () => {
                try {
                    const data = JSON.parse(xhr.responseText);
                    if (data.success) {
                        state.gatesUploadedVideoPath = data.video_path;
                        gatesEl.uploadStatus.textContent = `Uploaded: ${data.filename} (${data.size_mb}MB)`;
                        // Add to video dropdown and select it
                        const opt = document.createElement('option');
                        opt.value = data.video_path;
                        opt.textContent = `${data.filename} (uploaded)`;
                        opt.selected = true;
                        gatesEl.videoDropdown.appendChild(opt);
                        // Switch to video source
                        gatesSwitchSource('video');
                        gatesLoadVideoInfo();
                    } else {
                        gatesEl.uploadStatus.textContent = 'Error: ' + (data.error || 'Upload failed');
                    }
                } catch (e) {
                    gatesEl.uploadStatus.textContent = 'Error parsing response';
                }
            });
            xhr.addEventListener('error', () => {
                gatesEl.uploadStatus.textContent = 'Upload failed';
            });
            xhr.open('POST', '/api/video/upload');
            xhr.send(formData);
        }

        async function gatesDetect() {
            if (!state.gatesFrameId) {
                showStatus('Grab a frame first', 'error');
                return;
            }

            gatesEl.detectBtn.disabled = true;
            gatesEl.detectBtn.textContent = 'Detecting...';

            try {
                const res = await fetch('/api/calibrate/detect', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        frame_id: state.gatesFrameId,
                        discipline: gatesEl.discipline.value,
                        min_height: parseInt(gatesEl.minHeight.value),
                        max_height: parseInt(gatesEl.maxHeight.value),
                        sat_thresh: parseInt(gatesEl.satThresh.value),
                        val_thresh: parseInt(gatesEl.valThresh.value),
                    }),
                });
                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                state.gates = data.gates.map(g => ({ ...g, dismissed: false }));
                state.gpsGatePositions = {};  // Clear GPS on re-detection

                // Show review card with the original frame (pins rendered on top)
                gatesEl.reviewCard.style.display = 'block';
                gatesEl.frameImage.src = `/api/frame/${state.gatesFrameId}?t=${Date.now()}`;
                gatesEl.frameImage.onload = () => renderGatePins();

                // Show GPS walk button if GPS enabled
                gatesEl.gpsWalkGatesBtn.style.display = state.gpsEnabled ? '' : 'none';
                gatesEl.gpsGateSummary.style.display = 'none';

                // Hide verify card
                gatesEl.verifyCard.style.display = 'none';

                updateGatesCount();
                showStatus(`Detected ${data.gate_count} gates`, 'success');
            } catch (e) {
                showStatus('Error detecting gates: ' + e.message, 'error');
            } finally {
                gatesEl.detectBtn.disabled = false;
                gatesEl.detectBtn.textContent = 'Detect Gates';
            }
        }

        function renderGatePins() {
            // Remove existing pin elements
            document.querySelectorAll('.gate-pin, .gate-label, .gate-line, .gate-dismiss').forEach(el => el.remove());

            const img = gatesEl.frameImage;
            if (!img.naturalWidth) return;

            const displayWidth = img.clientWidth;
            const displayHeight = img.clientHeight;
            const scaleX = displayWidth / state.gatesFrameWidth;
            const scaleY = displayHeight / state.gatesFrameHeight;

            state.gates.forEach((gate, idx) => {
                if (gate.dismissed) return;

                const topX = gate.top[0] * scaleX;
                const topY = gate.top[1] * scaleY;
                const baseX = gate.base[0] * scaleX;
                const baseY = gate.base[1] * scaleY;

                // SVG line connecting top and base
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                line.classList.add('gate-line');
                line.style.cssText = `position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index:9;`;
                line.innerHTML = `<line x1="${topX}" y1="${topY}" x2="${baseX}" y2="${baseY}"
                    stroke="${gate.color === 'red' ? '#dc2626' : '#2563eb'}" stroke-width="2" stroke-dasharray="4,3" opacity="0.7"/>`;
                gatesEl.frameContainer.appendChild(line);

                // Top pin
                const topPin = document.createElement('div');
                topPin.className = `gate-pin ${gate.color}`;
                topPin.style.left = topX + 'px';
                topPin.style.top = topY + 'px';
                topPin.dataset.gateIdx = idx;
                topPin.dataset.point = 'top';
                // GPS indicator dot
                if (state.gpsEnabled && state.gpsGatePositions[idx]) {
                    const gpsDot = document.createElement('div');
                    gpsDot.className = 'gate-pin-gps';
                    topPin.style.position = 'absolute';  // ensure relative positioning for child
                    topPin.appendChild(gpsDot);
                }
                gatesEl.frameContainer.appendChild(topPin);

                // Base pin
                const basePin = document.createElement('div');
                basePin.className = `gate-pin ${gate.color}`;
                basePin.style.left = baseX + 'px';
                basePin.style.top = baseY + 'px';
                basePin.dataset.gateIdx = idx;
                basePin.dataset.point = 'base';
                gatesEl.frameContainer.appendChild(basePin);

                // Label near top
                const label = document.createElement('div');
                label.className = 'gate-label';
                label.textContent = gate.id;
                label.style.left = topX + 'px';
                label.style.top = topY + 'px';
                gatesEl.frameContainer.appendChild(label);

                // Dismiss button (X) near top-right of top pin
                const dismiss = document.createElement('button');
                dismiss.className = 'gate-dismiss';
                dismiss.textContent = '\u00d7';
                dismiss.style.left = (topX + 14) + 'px';
                dismiss.style.top = (topY - 14) + 'px';
                dismiss.dataset.gateIdx = idx;
                dismiss.addEventListener('click', (e) => {
                    e.stopPropagation();
                    dismissGate(parseInt(e.target.dataset.gateIdx));
                });
                gatesEl.frameContainer.appendChild(dismiss);
            });
        }

        function setupGatesPinDrag() {
            const container = gatesEl.frameContainer;

            function getPointerPos(e) {
                const rect = container.getBoundingClientRect();
                const touch = e.touches ? e.touches[0] : e;
                return {
                    x: touch.clientX - rect.left,
                    y: touch.clientY - rect.top,
                };
            }

            function onStart(e) {
                // Prevent mouse events that follow touch events (mobile fires both)
                if (e.type === 'mousedown' && e.sourceCapabilities && e.sourceCapabilities.firesTouchEvents) return;
                if (e.type === 'mousedown' && state._lastTouchTime && Date.now() - state._lastTouchTime < 500) return;
                if (e.type === 'touchstart') state._lastTouchTime = Date.now();

                const pin = e.target.closest('.gate-pin');
                if (!pin) {
                    // Check if we're in add gate mode
                    if (state.addGateMode && state.addGateTapCount >= 0) {
                        handleAddGateTap(e);
                    }
                    return;
                }
                e.preventDefault();
                pin.classList.add('dragging');
                state.draggingPin = {
                    gateIdx: parseInt(pin.dataset.gateIdx),
                    point: pin.dataset.point,
                };
            }

            function onMove(e) {
                if (!state.draggingPin) return;
                e.preventDefault();
                const pos = getPointerPos(e);
                const { gateIdx, point } = state.draggingPin;
                const gate = state.gates[gateIdx];
                if (!gate) return;

                const img = gatesEl.frameImage;
                const scaleX = state.gatesFrameWidth / img.clientWidth;
                const scaleY = state.gatesFrameHeight / img.clientHeight;

                // Update gate coords in original frame space
                gate[point][0] = Math.round(pos.x * scaleX);
                gate[point][1] = Math.round(pos.y * scaleY);

                renderGatePins();
            }

            function onEnd(e) {
                if (state.draggingPin) {
                    document.querySelectorAll('.gate-pin.dragging').forEach(p => p.classList.remove('dragging'));
                    state.draggingPin = null;
                }
            }

            container.addEventListener('mousedown', onStart);
            container.addEventListener('mousemove', onMove);
            container.addEventListener('mouseup', onEnd);
            container.addEventListener('mouseleave', onEnd);
            container.addEventListener('touchstart', onStart, { passive: false });
            container.addEventListener('touchmove', onMove, { passive: false });
            container.addEventListener('touchend', onEnd);
        }

        function handleAddGateTap(e) {
            const container = gatesEl.frameContainer;
            const rect = container.getBoundingClientRect();
            const touch = e.touches ? e.touches[0] : e;
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            const img = gatesEl.frameImage;
            const scaleX = state.gatesFrameWidth / img.clientWidth;
            const scaleY = state.gatesFrameHeight / img.clientHeight;

            const frameX = Math.round(x * scaleX);
            const frameY = Math.round(y * scaleY);

            if (state.addGateTapCount === 0) {
                // First tap = top of pole
                state.addGatePending = { top: [frameX, frameY] };
                state.addGateTapCount = -1;  // Locked briefly to prevent double-tap
                // Update instruction text with color
                const colorName = state.addGateColor.charAt(0).toUpperCase() + state.addGateColor.slice(1);
                const colorHex = state.addGateColor === 'red' ? '#dc2626' : '#2563eb';
                document.getElementById('gatesAddInstructionText').innerHTML =
                    `Now tap the <strong>base</strong> of the <strong style="color:${colorHex}">${colorName}</strong> gate pole.`;
                // Show a marker where top was tapped (color-matched)
                const markerColor = state.addGateColor === 'red' ? '#dc2626' : '#2563eb';
                const markerBg = state.addGateColor === 'red' ? 'rgba(220,38,38,0.4)' : 'rgba(37,99,235,0.4)';
                const topMarker = document.createElement('div');
                topMarker.id = 'addGateTopMarker';
                topMarker.style.cssText = `position:absolute; left:${x}px; top:${y}px; width:20px; height:20px;
                    border-radius:50%; border:3px solid ${markerColor}; background:${markerBg};
                    transform:translate(-50%,-50%); pointer-events:none; z-index:15;`;
                container.appendChild(topMarker);
                // Unlock after 400ms so finger can be lifted
                setTimeout(() => { state.addGateTapCount = 1; }, 400);
            } else if (state.addGateTapCount === 1) {
                // Second tap = base of pole
                const newId = state.gates.length > 0
                    ? Math.max(...state.gates.map(g => g.id)) + 1
                    : 1;
                const color = state.addGateColor;

                state.gates.push({
                    id: newId,
                    color: color,
                    top: state.addGatePending.top,
                    base: [frameX, frameY],
                    bbox: [0, 0, 0, 0],
                    confidence: 1.0,
                    dismissed: false,
                });

                // Remove top marker
                const marker = document.getElementById('addGateTopMarker');
                if (marker) marker.remove();

                // Exit add mode
                exitAddGateMode();

                renderGatePins();
                updateGatesCount();
            }
        }

        function enterAddGateMode(color) {
            // If already in add mode for same color, toggle off
            if (state.addGateMode && state.addGateColor === color) {
                exitAddGateMode();
                return;
            }
            state.addGateMode = true;
            state.addGateColor = color;
            state.addGateTapCount = 0;
            state.addGatePending = null;
            // Remove any stale top marker
            const marker = document.getElementById('addGateTopMarker');
            if (marker) marker.remove();

            // Show instructions with color-specific text
            const colorName = color.charAt(0).toUpperCase() + color.slice(1);
            const colorHex = color === 'red' ? '#dc2626' : '#2563eb';
            gatesEl.addInstructions.style.display = 'block';
            gatesEl.addInstructions.style.color = colorHex;
            document.getElementById('gatesAddInstructionText').innerHTML =
                `Tap the <strong>top</strong> of the <strong style="color:${colorHex}">${colorName}</strong> gate pole, then tap the <strong>base</strong>.`;

            // Highlight active button, reset the other
            const activeBtn = color === 'blue' ? gatesEl.addBlueBtn : gatesEl.addRedBtn;
            const otherBtn = color === 'blue' ? gatesEl.addRedBtn : gatesEl.addBlueBtn;
            const otherHex = color === 'blue' ? '#dc2626' : '#2563eb';
            activeBtn.style.background = colorHex;
            activeBtn.style.color = 'white';
            activeBtn.style.borderColor = colorHex;
            otherBtn.style.background = '';
            otherBtn.style.color = otherHex;
            otherBtn.style.borderColor = otherHex;
        }

        function exitAddGateMode() {
            state.addGateMode = false;
            state.addGateColor = null;
            state.addGateTapCount = 0;
            state.addGatePending = null;
            gatesEl.addInstructions.style.display = 'none';
            // Reset both buttons to outline with their color
            gatesEl.addBlueBtn.style.background = '';
            gatesEl.addBlueBtn.style.color = '#2563eb';
            gatesEl.addBlueBtn.style.borderColor = '#2563eb';
            gatesEl.addRedBtn.style.background = '';
            gatesEl.addRedBtn.style.color = '#dc2626';
            gatesEl.addRedBtn.style.borderColor = '#dc2626';
            const marker = document.getElementById('addGateTopMarker');
            if (marker) marker.remove();
        }

        function dismissGate(idx) {
            if (idx >= 0 && idx < state.gates.length) {
                state.gates[idx].dismissed = true;
                renderGatePins();
                updateGatesCount();
            }
        }

        function updateGatesCount() {
            const active = state.gates.filter(g => !g.dismissed);
            gatesEl.gatesCount.textContent = `${active.length} gate${active.length !== 1 ? 's' : ''} (${state.gates.filter(g => g.dismissed).length} dismissed)`;
            gatesEl.computeBtn.disabled = active.length < 4;
            gatesEl.minWarning.style.display = active.length < 4 ? 'block' : 'none';
        }

        async function gatesCompute() {
            const activeGates = state.gates.filter(g => !g.dismissed);
            if (activeGates.length < 4) {
                showStatus('Need at least 4 gates', 'error');
                return;
            }

            gatesEl.computeBtn.disabled = true;
            gatesEl.computeBtn.textContent = 'Computing...';

            const cameraId = state.gatesSourceType === 'rtsp'
                ? gatesEl.cameraSelect.value
                : 'uploaded';

            // Compute GPS world coordinates if available
            const worldCoords = gpsComputeWorldCoords();
            const gpsData = state.gpsEnabled && state.gpsCameraPosition ? {
                camera_position: state.gpsCameraPosition,
                gate_positions: state.gpsGatePositions,
            } : null;

            try {
                const res = await fetch('/api/calibrate/compute', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        frame_id: state.gatesFrameId,
                        camera_id: cameraId,
                        discipline: gatesEl.discipline.value,
                        gates: activeGates,
                        world_coords: worldCoords,
                        gps_data: gpsData,
                    }),
                });
                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                state.gatesCalibrationId = data.calibration_id;

                // Show verification
                gatesEl.verifyCard.style.display = 'block';
                gatesEl.verifyImage.src = data.verification_frame_url + '?t=' + Date.now();
                gatesEl.reprojError.textContent = data.reprojection_error.toFixed(1);
                document.getElementById('gatesFocalLength').textContent =
                    data.focal_length ? Math.round(data.focal_length) : '—';

                // Quality indicator (thresholds adjusted for virtual-plane error
                // which includes both base+top fits and is naturally higher)
                const err = data.reprojection_error;
                if (err < 15) {
                    gatesEl.reprojQuality.textContent = '(excellent)';
                    gatesEl.reprojQuality.style.color = 'var(--success)';
                } else if (err < 40) {
                    gatesEl.reprojQuality.textContent = '(good)';
                    gatesEl.reprojQuality.style.color = 'var(--primary)';
                } else {
                    gatesEl.reprojQuality.textContent = '(poor — adjust gates)';
                    gatesEl.reprojQuality.style.color = 'var(--danger)';
                }

                // Show per-gate errors so user knows which gates to adjust
                const perGateEl = document.getElementById('gatesPerGateErrors');
                if (perGateEl && data.per_gate_errors && data.per_gate_errors.length > 0) {
                    const gateErrHtml = data.per_gate_errors.map(ge => {
                        const color = ge.total_error < 10 ? 'var(--success)' :
                                      ge.total_error < 30 ? 'var(--primary)' : 'var(--danger)';
                        return `<span style="color:${color}; margin-right:8px;">Gate ${ge.gate_id}: ${ge.total_error}px</span>`;
                    }).join('');
                    perGateEl.innerHTML = gateErrHtml;
                    perGateEl.style.display = 'block';
                }

                showStatus(`Calibration computed (error: ${data.reprojection_error.toFixed(1)}px)`, 'success');
            } catch (e) {
                showStatus('Error computing calibration: ' + e.message, 'error');
            } finally {
                gatesEl.computeBtn.disabled = false;
                gatesEl.computeBtn.textContent = 'Compute Calibration';
                updateGatesCount();
            }
        }

        async function gatesAccept() {
            if (!state.gatesCalibrationId) return;

            gatesEl.acceptBtn.disabled = true;
            gatesEl.acceptBtn.textContent = 'Saving...';

            try {
                const res = await fetch('/api/calibrate/accept', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        calibration_id: state.gatesCalibrationId,
                    }),
                });
                const data = await res.json();
                if (data.error) {
                    showStatus(data.error, 'error');
                    return;
                }

                loadCalibrationStatus();

                // --- Transition to Free Skiing for trigger zones + session config ---

                // Store calibration context
                state.activeCalibrationId = state.gatesCalibrationId;
                state.activeCalibrationDiscipline = gatesEl.discipline.value;
                state.activeCalibrationCameraId = state.gatesSourceType === 'rtsp'
                    ? gatesEl.cameraSelect.value : 'uploaded';

                // Transfer frame from gates to free skiing state
                state.frameId = state.gatesFrameId;
                state.frameWidth = state.gatesFrameWidth;
                state.frameHeight = state.gatesFrameHeight;

                // Pre-select camera in free skiing mode
                if (state.gatesSourceType === 'rtsp') {
                    state.cameraId = state.activeCalibrationCameraId;
                    elements.sourceType.value = 'rtsp';
                    elements.camera.value = state.activeCalibrationCameraId;
                    elements.cameraSelect.style.display = 'block';
                    elements.videoSelect.style.display = 'none';
                    elements.sessionEndTimeSection.style.display = 'block';
                }

                // Load frame into free skiing frame container
                const frameUrl = `/api/frame/${state.frameId}?t=${Date.now()}`;
                elements.frameContainer.innerHTML =
                    `<img src="${frameUrl}" alt="Calibration frame" id="frameImage">`;

                // Show trigger zone + session config cards
                elements.frameCard.style.display = 'block';
                elements.configCard.style.display = 'block';
                elements.saveSection.style.display = 'block';

                // Setup drawing handlers and reset zones
                setupDrawingHandlers();
                state.startZone = null;
                state.endZone = null;
                state.cropZone = null;
                state.drawingMode = null;
                setDefaultEndTime();
                updateSaveButtonText();

                // Show calibration badge and switch to free skiing
                showCalibrationBadge();
                switchSubMode('freeSki');

                showStatus('Calibration saved! Now draw trigger zones and configure session.', 'success');
            } catch (e) {
                showStatus('Error saving calibration: ' + e.message, 'error');
            } finally {
                gatesEl.acceptBtn.disabled = false;
                gatesEl.acceptBtn.textContent = 'Accept Calibration';
            }
        }

        async function loadCalibrationStatus() {
            try {
                const res = await fetch('/api/calibrate/status');
                const data = await res.json();
                const cameras = data.cameras || {};
                let html = '';
                for (const [camId, info] of Object.entries(cameras)) {
                    if (info.calibrated) {
                        html += `<div style="margin-bottom: 6px;">
                            <strong>${camId}</strong>: calibrated
                            <span style="color: var(--success);">&#10003;</span>
                            <br><small>Error: ${info.reprojection_error}px | ${info.discipline} | ${info.timestamp?.split('T')[0] || ''}</small>
                        </div>`;
                    } else {
                        html += `<div style="margin-bottom: 6px;">
                            <strong>${camId}</strong>: <span style="color: var(--text-muted);">not calibrated</span>
                        </div>`;
                    }
                }
                gatesEl.statusList.innerHTML = html || 'No cameras configured';
            } catch (e) {
                gatesEl.statusList.innerHTML = 'Error loading status';
            }
        }

        // ========================================
        // GPS Functions (Bad Elf GNSS)
        // ========================================

        function gpsGetAccuracyClass(meters) {
            if (meters <= 0.2) return 'rtk';
            if (meters <= 1.0) return 'good';
            if (meters <= 3.0) return 'fair';
            return 'poor';
        }

        function gpsGetAccuracyLabel(meters) {
            const cls = gpsGetAccuracyClass(meters);
            const labels = { rtk: 'RTK Fix', good: 'Good', fair: 'Fair', poor: 'Poor' };
            return `±${meters.toFixed(2)}m (${labels[cls]})`;
        }

        function gpsStartWatching() {
            if (state.gpsWatchId !== null) return;
            if (!navigator.geolocation) {
                showStatus('Geolocation not available', 'error');
                return;
            }
            gatesEl.gpsStatusDot.classList.add('watching');
            state.gpsWatchId = navigator.geolocation.watchPosition(
                (pos) => {
                    state.gpsCurrentReading = {
                        lat: pos.coords.latitude,
                        lon: pos.coords.longitude,
                        alt: pos.coords.altitude || 0,
                        accuracy: pos.coords.accuracy,
                        timestamp: pos.timestamp,
                    };
                    gpsUpdateLiveDisplay();
                },
                (err) => {
                    console.error('GPS error:', err);
                    gatesEl.gpsLiveAccuracy.textContent = 'Error: ' + err.message;
                    gatesEl.gpsLiveAccuracy.className = 'gps-accuracy poor';
                },
                { enableHighAccuracy: true, maximumAge: 2000, timeout: 10000 }
            );
        }

        function gpsStopWatching() {
            if (state.gpsWatchId !== null) {
                navigator.geolocation.clearWatch(state.gpsWatchId);
                state.gpsWatchId = null;
            }
            gatesEl.gpsStatusDot.classList.remove('watching');
        }

        function gpsUpdateLiveDisplay() {
            const r = state.gpsCurrentReading;
            if (!r) {
                gatesEl.gpsLiveAccuracy.textContent = '—';
                gatesEl.gpsLiveAccuracy.className = 'gps-accuracy';
                return;
            }
            const cls = gpsGetAccuracyClass(r.accuracy);
            gatesEl.gpsLiveAccuracy.textContent = gpsGetAccuracyLabel(r.accuracy);
            gatesEl.gpsLiveAccuracy.className = `gps-accuracy ${cls}`;

            // Update walk overlay if active
            if (state.gpsWalkActive) {
                gatesEl.gpsWalkAccuracy.textContent = `±${r.accuracy.toFixed(2)}m`;
                gatesEl.gpsWalkAccuracy.style.color = cls === 'rtk' ? '#4ade80' : cls === 'good' ? '#60a5fa' : cls === 'fair' ? '#fbbf24' : '#f87171';
                // Quality bar: 100% at 0.05m, 0% at 5m (log scale)
                const pct = Math.max(0, Math.min(100, (1 - Math.log10(r.accuracy / 0.05) / Math.log10(5 / 0.05)) * 100));
                gatesEl.gpsWalkQualityFill.style.width = pct + '%';
                gatesEl.gpsWalkQualityFill.style.background = cls === 'rtk' ? '#4ade80' : cls === 'good' ? '#60a5fa' : cls === 'fair' ? '#fbbf24' : '#f87171';
            }
        }

        function gpsCaptureCamera() {
            const r = state.gpsCurrentReading;
            if (!r) {
                showStatus('No GPS reading yet — wait for signal', 'error');
                return;
            }
            state.gpsCameraPosition = { ...r };
            // Save to localStorage for reuse
            try {
                localStorage.setItem('skiframes_gps_camera', JSON.stringify(state.gpsCameraPosition));
            } catch (e) { /* ignore */ }
            gpsShowCameraInfo();
            showStatus(`Camera GPS captured: ±${r.accuracy.toFixed(2)}m`, 'success');
        }

        function gpsLoadSavedCamera() {
            try {
                const saved = JSON.parse(localStorage.getItem('skiframes_gps_camera'));
                if (saved && saved.lat) {
                    state.gpsCameraPosition = saved;
                    gpsShowCameraInfo();
                    showStatus('Loaded saved camera GPS position', 'success');
                }
            } catch (e) {
                showStatus('No saved camera position found', 'error');
            }
        }

        function gpsShowCameraInfo() {
            const p = state.gpsCameraPosition;
            if (!p) return;
            gatesEl.gpsCameraLat.textContent = p.lat.toFixed(6);
            gatesEl.gpsCameraLon.textContent = p.lon.toFixed(6);
            gatesEl.gpsCameraAcc.textContent = p.accuracy.toFixed(2);
            gatesEl.gpsCameraInfo.style.display = 'block';
            gatesEl.gpsStatusDot.classList.add('captured');
        }

        function gpsCheckSavedCamera() {
            try {
                const saved = JSON.parse(localStorage.getItem('skiframes_gps_camera'));
                if (saved && saved.lat) {
                    gatesEl.gpsLoadSaved.style.display = '';
                }
            } catch (e) { /* ignore */ }
        }

        // --- Walk Gates Mode ---

        function gpsStartWalkGates() {
            const activeGates = state.gates
                .map((g, idx) => ({ gate: g, idx }))
                .filter(item => !item.gate.dismissed);
            if (activeGates.length < 4) {
                showStatus('Need at least 4 active gates to walk', 'error');
                return;
            }
            if (!state.gpsCameraPosition) {
                showStatus('Capture camera GPS position first', 'error');
                return;
            }
            if (!state.gpsCurrentReading) {
                showStatus('Waiting for GPS signal...', 'error');
                return;
            }

            state.gpsWalkActive = true;
            state.gpsWalkGateList = activeGates;
            state.gpsWalkCurrentIdx = 0;

            gpsWalkRenderUI();
            gatesEl.gpsWalkOverlay.classList.add('visible');
        }

        function gpsWalkRenderUI() {
            const list = state.gpsWalkGateList;
            const cur = state.gpsWalkCurrentIdx;
            const gate = list[cur].gate;

            // Gate label
            gatesEl.gpsWalkGateLabel.textContent = `Gate ${gate.id} (${gate.color})`;
            gatesEl.gpsWalkGateLabel.style.color = gate.color === 'red' ? '#f87171' : '#60a5fa';

            // Progress dots
            let dotsHtml = '';
            list.forEach((item, i) => {
                const cls = i < cur ? 'captured' : i === cur ? 'current' : '';
                dotsHtml += `<div class="gps-walk-dot ${cls}"></div>`;
            });
            gatesEl.gpsWalkDots.innerHTML = dotsHtml;
        }

        function gpsWalkCaptureCurrent() {
            const r = state.gpsCurrentReading;
            if (!r) {
                showStatus('No GPS reading', 'error');
                return;
            }
            const item = state.gpsWalkGateList[state.gpsWalkCurrentIdx];
            state.gpsGatePositions[item.idx] = { ...r };
            gpsWalkAdvance();
        }

        function gpsWalkSkipCurrent() {
            gpsWalkAdvance();
        }

        function gpsWalkAdvance() {
            state.gpsWalkCurrentIdx++;
            if (state.gpsWalkCurrentIdx >= state.gpsWalkGateList.length) {
                gpsWalkFinish();
            } else {
                gpsWalkRenderUI();
            }
        }

        function gpsWalkFinish() {
            state.gpsWalkActive = false;
            gatesEl.gpsWalkOverlay.classList.remove('visible');

            // Count captured
            const captured = Object.keys(state.gpsGatePositions).length;
            const total = state.gpsWalkGateList.length;
            showStatus(`GPS captured for ${captured}/${total} gates`, captured === total ? 'success' : 'warning');

            // Show summary
            gpsRenderSummary();
            // Re-render pins to show GPS indicators
            renderGatePins();
        }

        function gpsRenderSummary() {
            const activeGates = state.gates
                .map((g, idx) => ({ gate: g, idx }))
                .filter(item => !item.gate.dismissed);

            let html = '<div style="font-weight: 600; margin-bottom: 4px;">GPS Positions:</div>';
            activeGates.forEach(item => {
                const gps = state.gpsGatePositions[item.idx];
                if (gps) {
                    const cls = gpsGetAccuracyClass(gps.accuracy);
                    html += `<div class="gps-summary-item">
                        <span class="gps-status-dot captured"></span>
                        ${item.gate.id}: <span class="gps-accuracy ${cls}" style="font-size: 11px; padding: 0 4px;">±${gps.accuracy.toFixed(2)}m</span>
                    </div>`;
                } else {
                    html += `<div class="gps-summary-item">
                        <span class="gps-status-dot"></span>
                        ${item.gate.id}: <span style="color: var(--text-muted);">skipped</span>
                    </div>`;
                }
            });
            gatesEl.gpsGateSummary.innerHTML = html;
            gatesEl.gpsGateSummary.style.display = 'block';
        }

        // --- WGS84 → Local ENU Conversion ---

        function gpsToENU(lat, lon, alt, refLat, refLon, refAlt) {
            // WGS84 ellipsoid constants
            const a = 6378137.0;             // semi-major axis (m)
            const f = 1 / 298.257223563;     // flattening
            const e2 = 2 * f - f * f;        // eccentricity squared

            const degToRad = Math.PI / 180;
            const latR = lat * degToRad;
            const lonR = lon * degToRad;
            const refLatR = refLat * degToRad;
            const refLonR = refLon * degToRad;

            // Convert both to ECEF
            function toECEF(latR, lonR, h) {
                const sinLat = Math.sin(latR);
                const cosLat = Math.cos(latR);
                const sinLon = Math.sin(lonR);
                const cosLon = Math.cos(lonR);
                const N = a / Math.sqrt(1 - e2 * sinLat * sinLat);
                return {
                    x: (N + h) * cosLat * cosLon,
                    y: (N + h) * cosLat * sinLon,
                    z: (N * (1 - e2) + h) * sinLat,
                };
            }

            const ref = toECEF(refLatR, refLonR, refAlt);
            const pt = toECEF(latR, lonR, alt);

            // Difference in ECEF
            const dx = pt.x - ref.x;
            const dy = pt.y - ref.y;
            const dz = pt.z - ref.z;

            // Rotation matrix ECEF → ENU
            const sinRefLat = Math.sin(refLatR);
            const cosRefLat = Math.cos(refLatR);
            const sinRefLon = Math.sin(refLonR);
            const cosRefLon = Math.cos(refLonR);

            const east  = -sinRefLon * dx + cosRefLon * dy;
            const north = -sinRefLat * cosRefLon * dx - sinRefLat * sinRefLon * dy + cosRefLat * dz;
            const up    =  cosRefLat * cosRefLon * dx + cosRefLat * sinRefLon * dy + sinRefLat * dz;

            return { east, north, up };
        }

        function gpsComputeWorldCoords() {
            if (!state.gpsEnabled || !state.gpsCameraPosition) return null;

            const activeGates = state.gates
                .map((g, idx) => ({ gate: g, idx }))
                .filter(item => !item.gate.dismissed);

            // Check all active gates have GPS
            for (const item of activeGates) {
                if (!state.gpsGatePositions[item.idx]) {
                    return null; // Fallback to Mode A
                }
            }

            const cam = state.gpsCameraPosition;
            const coords = activeGates.map(item => {
                const gps = state.gpsGatePositions[item.idx];
                const enu = gpsToENU(gps.lat, gps.lon, gps.alt, cam.lat, cam.lon, cam.alt);
                return [enu.east, enu.north, enu.up];
            });

            return coords;
        }

        function setupGatesEventListeners() {
            // Source type toggle
            gatesEl.sourceRtsp.addEventListener('click', () => gatesSwitchSource('rtsp'));
            gatesEl.sourceVideo.addEventListener('click', () => gatesSwitchSource('video'));

            // Video selection
            gatesEl.videoDropdown.addEventListener('change', gatesLoadVideoInfo);
            gatesEl.seekPosition.addEventListener('input', () => {
                gatesEl.seekTime.textContent = formatTime(parseFloat(gatesEl.seekPosition.value) || 0);
            });

            // Upload
            gatesEl.uploadVideo.addEventListener('click', () => gatesEl.videoUploadInput.click());
            gatesEl.videoUploadInput.addEventListener('change', gatesUploadVideo);

            // Grab frame
            gatesEl.grabFrame.addEventListener('click', gatesGrabFrame);

            // Advanced settings toggle
            gatesEl.advancedToggle.addEventListener('click', (e) => {
                e.preventDefault();
                const visible = gatesEl.advancedSettings.style.display !== 'none';
                gatesEl.advancedSettings.style.display = visible ? 'none' : 'block';
                gatesEl.advancedArrow.innerHTML = visible ? '&#9654;' : '&#9660;';
            });

            // Advanced sliders
            gatesEl.minHeight.addEventListener('input', () => { gatesEl.minHeightVal.textContent = gatesEl.minHeight.value; });
            gatesEl.maxHeight.addEventListener('input', () => { gatesEl.maxHeightVal.textContent = gatesEl.maxHeight.value; });
            gatesEl.satThresh.addEventListener('input', () => { gatesEl.satThreshVal.textContent = gatesEl.satThresh.value; });
            gatesEl.valThresh.addEventListener('input', () => { gatesEl.valThreshVal.textContent = gatesEl.valThresh.value; });

            // Detect
            gatesEl.detectBtn.addEventListener('click', gatesDetect);

            // Add gate (blue or red)
            gatesEl.addBlueBtn.addEventListener('click', () => enterAddGateMode('blue'));
            gatesEl.addRedBtn.addEventListener('click', () => enterAddGateMode('red'));
            gatesEl.cancelAdd.addEventListener('click', () => exitAddGateMode());

            // Compute
            gatesEl.computeBtn.addEventListener('click', gatesCompute);

            // Verify
            gatesEl.readjustBtn.addEventListener('click', () => {
                gatesEl.verifyCard.style.display = 'none';
            });
            gatesEl.acceptBtn.addEventListener('click', gatesAccept);

            // Pin drag
            setupGatesPinDrag();

            // Re-render pins on window resize
            window.addEventListener('resize', () => {
                if (state.mode === 'gates' && state.gates.length > 0) {
                    renderGatePins();
                }
            });

            // --- GPS Event Listeners ---
            gatesEl.gpsEnable.addEventListener('change', (e) => {
                state.gpsEnabled = e.target.checked;
                gatesEl.gpsBody.classList.toggle('visible', state.gpsEnabled);
                if (state.gpsEnabled) {
                    gpsStartWatching();
                    gpsCheckSavedCamera();
                    // Show walk gates button if review card is visible
                    if (gatesEl.reviewCard.style.display !== 'none') {
                        gatesEl.gpsWalkGatesBtn.style.display = '';
                    }
                } else {
                    gpsStopWatching();
                    gatesEl.gpsWalkGatesBtn.style.display = 'none';
                }
            });

            // Toggle row click (not just checkbox)
            document.getElementById('gpsToggleRow').addEventListener('click', (e) => {
                if (e.target !== gatesEl.gpsEnable) {
                    gatesEl.gpsEnable.checked = !gatesEl.gpsEnable.checked;
                    gatesEl.gpsEnable.dispatchEvent(new Event('change'));
                }
            });

            gatesEl.gpsCaptureCamera.addEventListener('click', gpsCaptureCamera);
            gatesEl.gpsLoadSaved.addEventListener('click', gpsLoadSavedCamera);
            gatesEl.gpsWalkGatesBtn.addEventListener('click', gpsStartWalkGates);
            gatesEl.gpsWalkCaptureBtn.addEventListener('click', gpsWalkCaptureCurrent);
            gatesEl.gpsWalkSkipBtn.addEventListener('click', gpsWalkSkipCurrent);
            gatesEl.gpsWalkCancelBtn.addEventListener('click', () => {
                state.gpsWalkActive = false;
                gatesEl.gpsWalkOverlay.classList.remove('visible');
            });
        }

        // Initialize on load
        init();
        setupStitchEventListeners();
        setupGatesEventListeners();
    </script>
</body>
</html>
